From b0cc0d07534ed9c086e66fed19bf6c4929fd099c Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhc@lemote.com>
Date: Thu, 1 Dec 2016 09:51:35 +0800
Subject: [PATCH 098/136] Loongson: Add basic support for LS2H bridge

Signed-off-by: Huacai Chen <chenhc@lemote.com>
Signed-off-by: Icenowy Zheng <uwu@icenowy.me>
---
 arch/mips/Kconfig                             |   2 +-
 arch/mips/boot/dts/Makefile                   |   1 +
 arch/mips/boot/dts/loongson/Makefile          |   4 +
 arch/mips/boot/dts/loongson/loongson3.dtsi    | 139 +++++++++++
 .../mips/boot/dts/loongson/loongson3_ls2h.dts | 213 +++++++++++++++++
 .../boot/dts/loongson/loongson3_rs780.dts     |  42 ++++
 arch/mips/configs/loongson3_defconfig         |   2 +-
 arch/mips/configs/loongson3_hpcconfig         |   2 +-
 arch/mips/include/asm/hpet.h                  |  15 +-
 arch/mips/include/asm/irq.h                   |   3 +
 .../include/asm/mach-loongson64/boot_param.h  |   7 +
 arch/mips/include/asm/mach-loongson64/irq.h   |  82 +++++++
 .../asm/mach-loongson64/loongson-pch.h        | 180 ++++++++++++++
 .../include/asm/mach-loongson64/workarounds.h |   1 +
 arch/mips/kernel/cacheinfo.c                  |   2 +
 arch/mips/loongson64/Kconfig                  |   8 +-
 arch/mips/loongson64/common/env.c             |  23 ++
 arch/mips/loongson64/common/init.c            |   4 +
 arch/mips/loongson64/common/mem.c             |   4 +
 arch/mips/loongson64/common/pci.c             |  20 +-
 arch/mips/loongson64/common/rtc.c             |  10 +-
 arch/mips/loongson64/common/setup.c           |  15 ++
 arch/mips/loongson64/common/time.c            |   2 +-
 arch/mips/loongson64/loongson-3/Makefile      |   4 +-
 arch/mips/loongson64/loongson-3/acpi_init.c   | 116 ++++-----
 arch/mips/loongson64/loongson-3/dma.c         |  60 ++++-
 arch/mips/loongson64/loongson-3/hpet.c        |  70 +++---
 arch/mips/loongson64/loongson-3/irq.c         | 105 +++------
 arch/mips/loongson64/loongson-3/ls2h-irq.c    | 222 ++++++++++++++++++
 .../loongson64/loongson-3/ls2h-platform.c     | 200 ++++++++++++++++
 arch/mips/loongson64/loongson-3/numa.c        |   6 +
 arch/mips/loongson64/loongson-3/platform.c    |  11 +
 arch/mips/loongson64/loongson-3/pm.c          |   5 +-
 arch/mips/loongson64/loongson-3/rs780-irq.c   |  89 +++++++
 .../loongson64/loongson-3/rs780-platform.c    |  58 +++++
 arch/mips/loongson64/loongson-3/sleep.S       |   7 +-
 arch/mips/loongson64/loongson-3/smp.c         |   6 +-
 arch/mips/pci/Makefile                        |   2 +-
 arch/mips/pci/fixup-loongson3.c               |   8 +-
 arch/mips/pci/ops-loongson3-ls2h.c            | 205 ++++++++++++++++
 ...{ops-loongson3.c => ops-loongson3-rs780.c} |  24 +-
 .../ethernet/stmicro/stmmac/stmmac_ethtool.c  |   8 -
 drivers/platform/mips/lemote3a-laptop.c       |  26 +-
 drivers/usb/dwc2/params.c                     |   9 +
 include/linux/device.h                        |   1 +
 include/linux/dma-mapping.h                   |   6 +
 kernel/dma/direct.c                           |  10 +-
 47 files changed, 1816 insertions(+), 223 deletions(-)
 create mode 100644 arch/mips/boot/dts/loongson/Makefile
 create mode 100644 arch/mips/boot/dts/loongson/loongson3.dtsi
 create mode 100644 arch/mips/boot/dts/loongson/loongson3_ls2h.dts
 create mode 100644 arch/mips/boot/dts/loongson/loongson3_rs780.dts
 create mode 100644 arch/mips/include/asm/mach-loongson64/loongson-pch.h
 create mode 100644 arch/mips/loongson64/loongson-3/ls2h-irq.c
 create mode 100644 arch/mips/loongson64/loongson-3/ls2h-platform.c
 create mode 100644 arch/mips/loongson64/loongson-3/rs780-irq.c
 create mode 100644 arch/mips/loongson64/loongson-3/rs780-platform.c
 create mode 100644 arch/mips/pci/ops-loongson3-ls2h.c
 rename arch/mips/pci/{ops-loongson3.c => ops-loongson3-rs780.c} (80%)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 7ef55b08f..9a7551dd4 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -3061,7 +3061,7 @@ endchoice
 choice
 	prompt "Kernel command line type" if !CMDLINE_OVERRIDE
 	default MIPS_CMDLINE_FROM_DTB if USE_OF && !ATH79 && !MACH_INGENIC && \
-					 !MIPS_MALTA && \
+					 !MACH_LOONGSON64 && !MIPS_MALTA && \
 					 !CAVIUM_OCTEON_SOC
 	default MIPS_CMDLINE_FROM_BOOTLOADER
 
diff --git a/arch/mips/boot/dts/Makefile b/arch/mips/boot/dts/Makefile
index 1e79cab8e..d429a69bf 100644
--- a/arch/mips/boot/dts/Makefile
+++ b/arch/mips/boot/dts/Makefile
@@ -4,6 +4,7 @@ subdir-y	+= cavium-octeon
 subdir-y	+= img
 subdir-y	+= ingenic
 subdir-y	+= lantiq
+subdir-y	+= loongson
 subdir-y	+= mscc
 subdir-y	+= mti
 subdir-y	+= netlogic
diff --git a/arch/mips/boot/dts/loongson/Makefile b/arch/mips/boot/dts/loongson/Makefile
new file mode 100644
index 000000000..0f1c4dcb0
--- /dev/null
+++ b/arch/mips/boot/dts/loongson/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_CPU_LOONGSON3)	+= loongson3_ls2h.dtb loongson3_rs780.dtb
+
+obj-y				+= $(patsubst %.dtb, %.dtb.o, $(dtb-y))
diff --git a/arch/mips/boot/dts/loongson/loongson3.dtsi b/arch/mips/boot/dts/loongson/loongson3.dtsi
new file mode 100644
index 000000000..c944b7057
--- /dev/null
+++ b/arch/mips/boot/dts/loongson/loongson3.dtsi
@@ -0,0 +1,139 @@
+// SPDX-License-Identifier: GPL-2.0
+/ {
+	/*
+	 * Loongson-3 may have as many as 4 nodes, each node has 4 cores.
+	 * Each core has its own pcache and cores in the same node share scache.
+	 */
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x0>;
+			next-level-cache = <&scache0>;
+		};
+
+		cpu@1 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x1>;
+			next-level-cache = <&scache0>;
+		};
+
+		cpu@2 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x2>;
+			next-level-cache = <&scache0>;
+		};
+
+		cpu@3 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x3>;
+			next-level-cache = <&scache0>;
+		};
+
+		cpu@4 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x4>;
+			next-level-cache = <&scache1>;
+		};
+
+		cpu@5 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x5>;
+			next-level-cache = <&scache1>;
+		};
+
+		cpu@6 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x6>;
+			next-level-cache = <&scache1>;
+		};
+
+		cpu@7 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x7>;
+			next-level-cache = <&scache1>;
+		};
+
+		cpu@8 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x8>;
+			next-level-cache = <&scache2>;
+		};
+
+		cpu@9 {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0x9>;
+			next-level-cache = <&scache2>;
+		};
+
+		cpu@a {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0xa>;
+			next-level-cache = <&scache2>;
+		};
+
+		cpu@b {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0xb>;
+			next-level-cache = <&scache2>;
+		};
+
+		cpu@c {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0xc>;
+			next-level-cache = <&scache3>;
+		};
+
+		cpu@d {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0xd>;
+			next-level-cache = <&scache3>;
+		};
+
+		cpu@e {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0xe>;
+			next-level-cache = <&scache3>;
+		};
+
+		cpu@f {
+			compatible = "loongson,loongson3";
+			device_type = "cpu";
+			reg = <0xf>;
+			next-level-cache = <&scache3>;
+		};
+
+		scache0: l2-cache0 {
+			compatible = "cache";
+		};
+
+		scache1: l2-cache1 {
+			compatible = "cache";
+		};
+
+		scache2: l2-cache2 {
+			compatible = "cache";
+		};
+
+		scache3: l2-cache3 {
+			compatible = "cache";
+		};
+	};
+};
diff --git a/arch/mips/boot/dts/loongson/loongson3_ls2h.dts b/arch/mips/boot/dts/loongson/loongson3_ls2h.dts
new file mode 100644
index 000000000..31894141a
--- /dev/null
+++ b/arch/mips/boot/dts/loongson/loongson3_ls2h.dts
@@ -0,0 +1,213 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+#include "loongson3.dtsi"
+/ {
+	model = "loongson,generic";
+	compatible = "loongson,loongson3";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+	};
+
+	cpuic: interrupt-controller {
+		compatible = "mti,cpu-interrupt-controller";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+	};
+
+	platic: interrupt-controller@1bd00040 {
+		compatible = "loongson,ls2h-interrupt-controller";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupts = <3>;
+		interrupt-parent = <&cpuic>;
+	};
+
+	aliases {
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+
+	platform {
+		compatible = "loongson,nbus", "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		ranges = <0x000 0x00000000 0x000 0x00000000 0x20000000
+			  0x000 0x40000000 0x000 0x40000000 0x40000000
+			  0xe00 0x00000000 0xe00 0x00000000 0x80000000>;
+
+		uart0: serial@1be80000 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x1be80000 0x1000>;
+			clock-frequency = <125000000>;
+			interrupts = <66>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		uart1: serial@1be81000 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x1be81000 0x1000>;
+			clock-frequency = <125000000>;
+			interrupts = <67>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		uart2: serial@1be82000 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x1be82000 0x1000>;
+			clock-frequency = <125000000>;
+			interrupts = <68>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		uart3: serial@1be83000 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x1be83000 0x1000>;
+			clock-frequency = <125000000>;
+			interrupts = <69>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		i2c0: i2c@1be90000 {
+			compatible = "loongson,ls2h-i2c";
+			reg = <0 0x1be90000 0x8>;
+			interrupts = <71>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c1: i2c@1be91000 {
+			compatible = "loongson,ls2h-i2c";
+			reg = <0 0x1be91000 0x8>;
+			interrupts = <72>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		rtc0: rtc@1bef8000 {
+			compatible = "loongson,ls2h-rtc";
+			reg = <0 0x1bef8000 0x100>;
+			interrupts = <78>;
+			interrupt-parent = <&platic>;
+		};
+
+		nand@1bee0000 {
+			compatible = "loongson,ls2h-nand";
+			reg =  <0 0x1bee0000 0x20
+				0 0x1bd00100 0x01>;
+			interrupts = <86>;
+			interrupt-parent = <&platic>;
+			status = "disabled";
+
+			partitions {
+				compatible = "fixed-partitions";
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				partition@0x00000000 {
+					label = "kernel_partition";
+					reg = <0x00000000 0x01400000>;
+				};
+
+				partition@0x01400000 {
+					label = "os_partition";
+					reg = <0x01400000 0x00000000>;
+				};
+			};
+		};
+
+		ehci@1be00000 {
+			compatible = "generic-ehci", "usb-ehci";
+			reg = <0 0x1be00000 0x1000>;
+			interrupts = <96>;
+			interrupt-parent = <&platic>;
+		};
+
+		ohci@1be08000 {
+			compatible = "generic-ohci", "usb-ohci";
+			reg = <0 0x1be08000 0x1000>;
+			interrupts = <97>;
+			interrupt-parent = <&platic>;
+			num-ports = <6>;
+		};
+
+		otg@1be60000 {
+			compatible = "loongson,dwc2", "usb-otg";
+			reg = <0 0x1be60000 0x20000>;
+			interrupts = <98>;
+			interrupt-parent = <&platic>;
+			dr_mode = "host";
+		};
+
+		gmac0: ethernet@1be10000 {
+			compatible = "snps,dwmac-3.70a", "loongson,stmmaceth";
+			reg = <0 0x1be10000 0x1000>;
+			interrupts = <99>;
+			interrupt-names = "macirq";
+			interrupt-parent = <&platic>;
+			phy-mode = "rgmii";
+			bus_id = <0x0>;
+			phy_addr = <0x0>;
+			dma-mask = <0xffffffff 0xffffffff>;
+		};
+
+		gmac1: ethernet@1be18000 {
+			compatible = "snps,dwmac-3.70a", "loongson,stmmaceth";
+			reg = <0 0x1be18000 0x1000>;
+			interrupts = <100>;
+			interrupt-names = "macirq";
+			interrupt-parent = <&platic>;
+			phy-mode = "rgmii";
+			bus_id = <0x1>;
+			phy_addr = <0x1>;
+			dma-mask = <0xffffffff 0xffffffff>;
+		};
+
+		ahci@1be30000 {
+			compatible = "generic-ahci";
+			reg = <0 0x1be30000 0x200>;
+			interrupts = <101>;
+			interrupt-parent = <&platic>;
+		};
+
+		gpu@1be40000 {
+			compatible = "vivante,gc";
+			reg = <0x000 0x1be40000 0x0001000
+			       0xe00 0x04000000 0x8000000>;
+			reg-names = "gpu_base", "gpu_mem";
+			interrupts = <102>;
+			interrupt-names = "gpu_irq";
+			interrupt-parent = <&platic>;
+		};
+
+		dc@1be50000 {
+			compatible = "loongson,ls2h-drmfb";
+			reg = <0x000 0x1be50000 0x0002000
+			       0xe00 0x02000000 0x2000000>;
+			interrupts = <103>;
+			interrupt-parent = <&platic>;
+		};
+
+		audio: audio@1be20000 {
+			compatible = "loongson,ls2h-audio";
+			reg = <0 0x1be20000 0x180>;
+			interrupts = <121>;
+			interrupt-parent = <&platic>;
+		};
+	};
+};
diff --git a/arch/mips/boot/dts/loongson/loongson3_rs780.dts b/arch/mips/boot/dts/loongson/loongson3_rs780.dts
new file mode 100644
index 000000000..0737f6d2f
--- /dev/null
+++ b/arch/mips/boot/dts/loongson/loongson3_rs780.dts
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+/dts-v1/;
+#include "loongson3.dtsi"
+/ {
+	model = "loongson,generic";
+	compatible = "loongson,loongson3";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+	};
+
+	cpuic: interrupt-controller {
+		compatible = "mti,cpu-interrupt-controller";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+	};
+
+	i8259: interrupt-controller@20 {
+		compatible = "intel,i8259";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupts = <3>;
+		interrupt-parent = <&cpuic>;
+	};
+
+	isa {
+		compatible = "isa";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		ranges = <1 0 0 0 0x1000>;
+
+		rtc0: rtc@70 {
+			compatible = "motorola,mc146818";
+			reg = <1 0x70 0x8>;
+			interrupts = <8>;
+			interrupt-parent = <&i8259>;
+		};
+	};
+};
diff --git a/arch/mips/configs/loongson3_defconfig b/arch/mips/configs/loongson3_defconfig
index 9a8abc819..ff31ded36 100644
--- a/arch/mips/configs/loongson3_defconfig
+++ b/arch/mips/configs/loongson3_defconfig
@@ -1,7 +1,7 @@
 CONFIG_MACH_LOONGSON64=y
 CONFIG_SWIOTLB=y
 CONFIG_LOONGSON_MACH3X=y
-CONFIG_RS780_HPET=y
+CONFIG_LOONGSON_HPET=y
 CONFIG_CPU_LOONGSON3=y
 CONFIG_LOONGSON3_CPUAUTOPLUG=y
 CONFIG_64BIT=y
diff --git a/arch/mips/configs/loongson3_hpcconfig b/arch/mips/configs/loongson3_hpcconfig
index 6f4eae484..6a9dcf142 100644
--- a/arch/mips/configs/loongson3_hpcconfig
+++ b/arch/mips/configs/loongson3_hpcconfig
@@ -1,7 +1,7 @@
 CONFIG_MACH_LOONGSON64=y
 CONFIG_SWIOTLB=y
 CONFIG_LOONGSON_MACH3X=y
-CONFIG_RS780_HPET=y
+CONFIG_LOONGSON_HPET=y
 CONFIG_CPU_LOONGSON3=y
 CONFIG_LOONGSON3_CPUAUTOPLUG=y
 CONFIG_LOONGSON3_ENHANCEMENT=y
diff --git a/arch/mips/include/asm/hpet.h b/arch/mips/include/asm/hpet.h
index d47268ece..ab9c69d2e 100644
--- a/arch/mips/include/asm/hpet.h
+++ b/arch/mips/include/asm/hpet.h
@@ -2,7 +2,7 @@
 #ifndef _ASM_HPET_H
 #define _ASM_HPET_H
 
-#ifdef CONFIG_RS780_HPET
+#ifdef CONFIG_LOONGSON_HPET
 
 #define HPET_MMAP_SIZE		1024
 
@@ -64,11 +64,14 @@
 #define HPET_MIN_PERIOD		100000UL
 
 #define HPET_ADDR		0x20000
-#define HPET_MMIO_ADDR	0x90000e0000020000
-#define HPET_FREQ		14318780
-#define HPET_COMPARE_VAL	((HPET_FREQ + HZ / 2) / HZ)
-#define HPET_T0_IRQ		0
+#define LS2H_HPET_BASE		0x900000001bec0000
+#define LS2H_HPET_FREQ		125000000
+#define LS2H_HPET_T0_IRQ	LS2H_PCH_HPET_IRQ
+#define RS780_HPET_BASE		0x90000e0000020000
+#define RS780_HPET_FREQ		14318780
+#define RS780_HPET_T0_IRQ	RS780_PCH_HPET_IRQ
+#define HPET_COMPARE_VAL	((hpet_freq + HZ / 2) / HZ)
 
 extern void __init setup_hpet_timer(void);
-#endif /* CONFIG_RS780_HPET */
+#endif /* CONFIG_LOONGSON_HPET */
 #endif /* _ASM_HPET_H */
diff --git a/arch/mips/include/asm/irq.h b/arch/mips/include/asm/irq.h
index c5d351786..4e3a7c3c4 100644
--- a/arch/mips/include/asm/irq.h
+++ b/arch/mips/include/asm/irq.h
@@ -53,6 +53,7 @@ static inline int irq_canonicalize(int irq)
 #define irq_canonicalize(irq) (irq)	/* Sane hardware, sane code ... */
 #endif
 
+struct irq_data;
 asmlinkage void plat_irq_dispatch(void);
 
 extern void do_IRQ(unsigned int irq);
@@ -63,6 +64,8 @@ extern void spurious_interrupt(void);
 extern int allocate_irqno(void);
 extern void alloc_legacy_irqno(void);
 extern void free_irqno(unsigned int irq);
+extern int plat_set_irq_affinity(struct irq_data *d,
+				 const struct cpumask *affinity, bool force);
 
 /*
  * Before R2 the timer and performance counter interrupts were both fixed to
diff --git a/arch/mips/include/asm/mach-loongson64/boot_param.h b/arch/mips/include/asm/mach-loongson64/boot_param.h
index 016acd1c3..6d0cf7d74 100644
--- a/arch/mips/include/asm/mach-loongson64/boot_param.h
+++ b/arch/mips/include/asm/mach-loongson64/boot_param.h
@@ -98,6 +98,7 @@ struct system_loongson {
 	char tcm_name[32];
 	u64 tcm_base_addr;
 	u64 workarounds; /* see workarounds.h */
+	u64 of_dtb_addr; /* NULL if not support */
 } __packed;
 
 struct irq_source_routing_table {
@@ -208,7 +209,10 @@ struct loongson_system_configuration {
 	u64 poweroff_addr;
 	u64 suspend_addr;
 	u64 vgabios_addr;
+	u64 low_physmem_start;
+	u64 high_physmem_start;
 	u32 dma_mask_bits;
+	u32 ec_sci_irq;
 	char ecname[32];
 	u32 nr_uarts;
 	struct uart_device uarts[MAX_UARTS];
@@ -217,6 +221,9 @@ struct loongson_system_configuration {
 	u64 workarounds;
 };
 
+extern void *loongson_fdt_blob;
+extern u32 __dtb_loongson3_ls2h_begin[];
+extern u32 __dtb_loongson3_rs780_begin[];
 extern struct efi_memory_map_loongson *loongson_memmap;
 extern struct loongson_system_configuration loongson_sysconf;
 
diff --git a/arch/mips/include/asm/mach-loongson64/irq.h b/arch/mips/include/asm/mach-loongson64/irq.h
index be9f727a9..252473f3a 100644
--- a/arch/mips/include/asm/mach-loongson64/irq.h
+++ b/arch/mips/include/asm/mach-loongson64/irq.h
@@ -6,9 +6,13 @@
 
 #ifdef CONFIG_CPU_LOONGSON3
 
+#define NR_IRQS	256
 /* cpu core interrupt numbers */
 #define MIPS_CPU_IRQ_BASE 56
 
+#define IPI_IRQ_OFFSET 4
+#define NR_DIRQS (32 - IPI_IRQ_OFFSET)
+
 #define LOONGSON_UART_IRQ   (MIPS_CPU_IRQ_BASE + 2) /* UART */
 #define LOONGSON_BRIDGE_IRQ (MIPS_CPU_IRQ_BASE + 3) /* CASCADE */
 #define LOONGSON_TIMER_IRQ  (MIPS_CPU_IRQ_BASE + 7) /* CPU Timer */
@@ -35,9 +39,87 @@
 
 #define LOONGSON_INT_COREx_INTy(x, y)	(1<<(x) | 1<<(y+4))	/* route to int y of core x */
 
+#define LS2H_PCH_IRQ_BASE		64
+#define LS2H_PCH_ACPI_IRQ		(LS2H_PCH_IRQ_BASE + 0)
+#define LS2H_PCH_HPET_IRQ		(LS2H_PCH_IRQ_BASE + 1)
+#define LS2H_PCH_UART0_IRQ		(LS2H_PCH_IRQ_BASE + 2)
+#define LS2H_PCH_UART1_IRQ		(LS2H_PCH_IRQ_BASE + 3)
+#define LS2H_PCH_UART2_IRQ		(LS2H_PCH_IRQ_BASE + 4)
+#define LS2H_PCH_UART3_IRQ		(LS2H_PCH_IRQ_BASE + 5)
+#define LS2H_PCH_SPI_IRQ		(LS2H_PCH_IRQ_BASE + 6)
+#define LS2H_PCH_I2C0_IRQ		(LS2H_PCH_IRQ_BASE + 7)
+#define LS2H_PCH_I2C1_IRQ		(LS2H_PCH_IRQ_BASE + 8)
+#define LS2H_PCH_AC97_IRQ		(LS2H_PCH_IRQ_BASE + 9)
+#define LS2H_PCH_DMA0_IRQ		(LS2H_PCH_IRQ_BASE + 10)
+#define LS2H_PCH_DMA1_IRQ		(LS2H_PCH_IRQ_BASE + 11)
+#define LS2H_PCH_DMA2_IRQ		(LS2H_PCH_IRQ_BASE + 12)
+#define LS2H_PCH_LPC_IRQ		(LS2H_PCH_IRQ_BASE + 13)
+#define LS2H_PCH_RTC_INT0_IRQ		(LS2H_PCH_IRQ_BASE + 14)
+#define LS2H_PCH_RTC_INT1_IRQ		(LS2H_PCH_IRQ_BASE + 15)
+#define LS2H_PCH_RTC_INT2_IRQ		(LS2H_PCH_IRQ_BASE + 16)
+#define LS2H_PCH_TOY_INT0_IRQ		(LS2H_PCH_IRQ_BASE + 17)
+#define LS2H_PCH_TOY_INT1_IRQ		(LS2H_PCH_IRQ_BASE + 18)
+#define LS2H_PCH_TOY_INT2_IRQ		(LS2H_PCH_IRQ_BASE + 19)
+#define LS2H_PCH_RTC_TICK_IRQ		(LS2H_PCH_IRQ_BASE + 20)
+#define LS2H_PCH_TOY_TICK_IRQ		(LS2H_PCH_IRQ_BASE + 21)
+#define LS2H_PCH_NAND_IRQ		(LS2H_PCH_IRQ_BASE + 22)
+#define LS2H_PCH_SYS_INTN_IRQ		(LS2H_PCH_IRQ_BASE + 23)
+#define LS2H_PCH_EHCI_IRQ		(LS2H_PCH_IRQ_BASE + 32)
+#define LS2H_PCH_OHCI_IRQ		(LS2H_PCH_IRQ_BASE + 33)
+#define LS2H_PCH_OTG_IRQ		(LS2H_PCH_IRQ_BASE + 34)
+#define LS2H_PCH_GMAC0_IRQ		(LS2H_PCH_IRQ_BASE + 35)
+#define LS2H_PCH_GMAC1_IRQ		(LS2H_PCH_IRQ_BASE + 36)
+#define LS2H_PCH_SATA_IRQ		(LS2H_PCH_IRQ_BASE + 37)
+#define LS2H_PCH_GPU_IRQ		(LS2H_PCH_IRQ_BASE + 38)
+#define LS2H_PCH_DC_IRQ			(LS2H_PCH_IRQ_BASE + 39)
+#define LS2H_PCH_PWM0_IRQ		(LS2H_PCH_IRQ_BASE + 40)
+#define LS2H_PCH_PWM1_IRQ		(LS2H_PCH_IRQ_BASE + 41)
+#define LS2H_PCH_PWM2_IRQ		(LS2H_PCH_IRQ_BASE + 42)
+#define LS2H_PCH_PWM3_IRQ		(LS2H_PCH_IRQ_BASE + 43)
+#define LS2H_PCH_HT0_IRQ		(LS2H_PCH_IRQ_BASE + 44)
+#define LS2H_PCH_HT1_IRQ		(LS2H_PCH_IRQ_BASE + 45)
+#define LS2H_PCH_HT2_IRQ		(LS2H_PCH_IRQ_BASE + 46)
+#define LS2H_PCH_HT3_IRQ		(LS2H_PCH_IRQ_BASE + 47)
+#define LS2H_PCH_HT4_IRQ		(LS2H_PCH_IRQ_BASE + 48)
+#define LS2H_PCH_HT5_IRQ		(LS2H_PCH_IRQ_BASE + 49)
+#define LS2H_PCH_HT6_IRQ		(LS2H_PCH_IRQ_BASE + 50)
+#define LS2H_PCH_HT7_IRQ		(LS2H_PCH_IRQ_BASE + 51)
+#define LS2H_PCH_PCIE_PORT0_IRQ		(LS2H_PCH_IRQ_BASE + 52)
+#define LS2H_PCH_PCIE_PORT1_IRQ		(LS2H_PCH_IRQ_BASE + 53)
+#define LS2H_PCH_PCIE_PORT2_IRQ		(LS2H_PCH_IRQ_BASE + 54)
+#define LS2H_PCH_PCIE_PORT3_IRQ		(LS2H_PCH_IRQ_BASE + 55)
+#define LS2H_PCH_SATA_PHY_IRQ		(LS2H_PCH_IRQ_BASE + 56)
+#define LS2H_PCH_HDA_IRQ		(LS2H_PCH_IRQ_BASE + 57)
+#define LS2H_PCH_GPIO0_IRQ		(LS2H_PCH_IRQ_BASE + 64)
+#define LS2H_PCH_GPIO1_IRQ		(LS2H_PCH_IRQ_BASE + 65)
+#define LS2H_PCH_GPIO2_IRQ		(LS2H_PCH_IRQ_BASE + 66)
+#define LS2H_PCH_GPIO3_IRQ		(LS2H_PCH_IRQ_BASE + 67)
+#define LS2H_PCH_GPIO4_IRQ		(LS2H_PCH_IRQ_BASE + 68)
+#define LS2H_PCH_GPIO5_IRQ		(LS2H_PCH_IRQ_BASE + 69)
+#define LS2H_PCH_GPIO6_IRQ		(LS2H_PCH_IRQ_BASE + 70)
+#define LS2H_PCH_GPIO7_IRQ		(LS2H_PCH_IRQ_BASE + 71)
+#define LS2H_PCH_GPIO8_IRQ		(LS2H_PCH_IRQ_BASE + 72)
+#define LS2H_PCH_GPIO9_IRQ		(LS2H_PCH_IRQ_BASE + 73)
+#define LS2H_PCH_GPIO10_IRQ		(LS2H_PCH_IRQ_BASE + 74)
+#define LS2H_PCH_GPIO11_IRQ		(LS2H_PCH_IRQ_BASE + 75)
+#define LS2H_PCH_GPIO12_IRQ		(LS2H_PCH_IRQ_BASE + 76)
+#define LS2H_PCH_GPIO13_IRQ		(LS2H_PCH_IRQ_BASE + 77)
+#define LS2H_PCH_GPIO14_IRQ		(LS2H_PCH_IRQ_BASE + 78)
+#define LS2H_PCH_GPIO15_IRQ		(LS2H_PCH_IRQ_BASE + 79)
+#define LS2H_PCH_LAST_IRQ		(LS2H_PCH_IRQ_BASE + 160)
+
+#define RS780_PCH_HPET_IRQ		0
+#define RS780_PCH_ACPI_IRQ		7
+
 #endif
 
+extern unsigned int loongson_ipi_irq2pos[NR_IRQS];
+extern unsigned int loongson_ipi_pos2irq[NR_DIRQS];
+
 extern void fixup_irqs(void);
+extern void create_ipi_dirq(unsigned int irq);
+extern void destroy_ipi_dirq(unsigned int irq);
+extern void loongson3_send_irq_by_ipi(int cpu, int irqs);
 extern void loongson3_ipi_interrupt(struct pt_regs *regs);
 
 #include_next <irq.h>
diff --git a/arch/mips/include/asm/mach-loongson64/loongson-pch.h b/arch/mips/include/asm/mach-loongson64/loongson-pch.h
new file mode 100644
index 000000000..1744774a0
--- /dev/null
+++ b/arch/mips/include/asm/mach-loongson64/loongson-pch.h
@@ -0,0 +1,180 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ *  Copyright (C) 2013, Loongson Technology Corporation Limited, Inc.
+ *  Copyright (C) 2014-2017, Lemote, Inc.
+ */
+#ifndef _LOONGSON_PCH_H
+#define _LOONGSON_PCH_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/addrspace.h>
+
+/* ============== LS2H registers =============== */
+
+#define LS2H_PCH_REG_BASE		0x1b000000
+
+/* CHIP CONFIG regs */
+#define LS2H_CHIPCFG_REG_BASE		(LS2H_PCH_REG_BASE + 0x00d00000)
+/* INT CONFIG regs */
+#define LS2H_INT_REG_BASE		(LS2H_PCH_REG_BASE + 0x00d00040)
+/* DMA ORDER regs */
+#define LS2H_DMA_ORDER_REG_BASE		(LS2H_PCH_REG_BASE + 0x00d00100)
+/* WIN CONFIG regs */
+#define LS2H_WIN_CFG_BASE		(LS2H_PCH_REG_BASE + 0x00d80000)
+/* GPU regs */
+#define LS2H_GPU_REG_BASE		(LS2H_PCH_REG_BASE + 0x00e40000)
+/* DC regs */
+#define LS2H_DC_REG_BASE		(LS2H_PCH_REG_BASE + 0x00e50000)
+/* HPET regs */
+#define LS2H_HPET_REG_BASE		(LS2H_PCH_REG_BASE + 0x00ec0000)
+/* NAND regs */
+#define LS2H_NAND_REG_BASE		(LS2H_PCH_REG_BASE + 0x00ee0000)
+/* ACPI regs */
+#define LS2H_ACPI_REG_BASE		(LS2H_PCH_REG_BASE + 0x00ef0000)
+/* LPC regs */
+#define LS2H_LPC_IO_BASE		(LS2H_PCH_REG_BASE + 0x00f00000)
+#define LS2H_LPC_REG_BASE		(LS2H_PCH_REG_BASE + 0x00f10000)
+
+#define LS2H_INT_ISR0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0040)
+#define LS2H_INT_IEN0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0044)
+#define LS2H_INT_SET0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0048)
+#define LS2H_INT_CLR0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x004c)
+#define LS2H_INT_POL0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0050)
+#define LS2H_INT_EDGE0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0054)
+#define LS2H_GPIO_CFG_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x00c0)
+#define LS2H_GPIO_OE_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x00c4)
+#define LS2H_GPIO_IN_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x00c8)
+#define LS2H_GPIO_OUT_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x00cc)
+#define LS2H_CHIP_CFG0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0200)
+#define LS2H_CHIP_CFG1_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0204)
+#define LS2H_CHIP_CFG2_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0208)
+#define LS2H_CHIP_CFG3_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x020c)
+#define LS2H_CHIP_SAMP0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0210)
+#define LS2H_CHIP_SAMP1_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0214)
+#define LS2H_CHIP_SAMP2_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0218)
+#define LS2H_CHIP_SAMP3_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x021c)
+#define LS2H_CLK_CTRL0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0220)
+#define LS2H_CLK_CTRL1_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0224)
+#define LS2H_CLK_CTRL2_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0228)
+#define LS2H_CLK_CTRL3_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x022c)
+#define LS2H_PIXCLK0_CTRL0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0230)
+#define LS2H_PIXCLK0_CTRL1_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0234)
+#define LS2H_PIXCLK1_CTRL0_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x0238)
+#define LS2H_PIXCLK1_CTRL1_REG		(void *)TO_UNCAC(LS2H_CHIPCFG_REG_BASE + 0x023c)
+
+#define LS2H_M1_WIN4_BASE_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0120)
+#define LS2H_M1_WIN4_MASK_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0160)
+#define LS2H_M1_WIN4_MMAP_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x01a0)
+#define LS2H_M1_WIN6_BASE_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0130)
+#define LS2H_M1_WIN6_MASK_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0170)
+#define LS2H_M1_WIN6_MMAP_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x01b0)
+#define LS2H_M4_WIN0_BASE_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0400)
+#define LS2H_M4_WIN0_MASK_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0440)
+#define LS2H_M4_WIN0_MMAP_REG		(void *)TO_UNCAC(LS2H_WIN_CFG_BASE + 0x0480)
+
+#define LS2H_PM_SOC_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0000)
+#define LS2H_PM_RESUME_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0004)
+#define LS2H_PM_RTC_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0008)
+#define LS2H_PM_EVT_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x000c)
+#define LS2H_PM_ENA_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0010)
+#define LS2H_PM_CNT_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0014)
+#define LS2H_PM_TMR_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0018)
+#define LS2H_P_CNT_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x001c)
+#define LS2H_P_LVL2_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0020)
+#define LS2H_P_LVL3_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0024)
+#define LS2H_GPE0_STS_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0028)
+#define LS2H_GPE0_ENA_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x002c)
+#define LS2H_RST_CNT_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0030)
+#define LS2H_WD_SET_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0034)
+#define LS2H_WD_TIMER_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0038)
+#define LS2H_DVFS_CNT_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x003c)
+#define LS2H_DVFS_STS_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0040)
+#define LS2H_MS_CNT_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0044)
+#define LS2H_MS_THT_REG			(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0048)
+#define	LS2H_THSENS_CNT_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x004c)
+#define LS2H_GEN_RTC1_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0050)
+#define LS2H_GEN_RTC2_REG		(void *)TO_UNCAC(LS2H_ACPI_REG_BASE + 0x0054)
+
+#define LS2H_LPC_INT_CTL		(void *)TO_UNCAC(LS2H_LPC_REG_BASE + 0x0)
+#define LS2H_LPC_INT_ENA		(void *)TO_UNCAC(LS2H_LPC_REG_BASE + 0x4)
+#define LS2H_LPC_INT_STS		(void *)TO_UNCAC(LS2H_LPC_REG_BASE + 0x8)
+#define LS2H_LPC_INT_CLR		(void *)TO_UNCAC(LS2H_LPC_REG_BASE + 0xc)
+
+#define LS2H_PCIE_MAX_PORTNUM			3
+#define LS2H_PCIE_MEM0_BASE(portnum)		(0x10000000 + (portnum << 25))
+#define LS2H_PCIE_MEM1_BASE(portnum)		(0x40000000 + (portnum << 28))
+#define LS2H_PCIE_IO_BASE(portnum)		CKSEG1ADDR(0x18100000 + (portnum << 22))
+#define LS2H_PCIE_PORT_HEAD_BASE(portnum)	CKSEG1ADDR(0x18114000 + (portnum << 22))
+#define LS2H_PCIE_DEV_HEAD_BASE(portnum)	CKSEG1ADDR(0x18116000 + (portnum << 22))
+#define LS2H_PCIE_PORT_REG_BASE(portnum)	CKSEG1ADDR(0x18118000 + (portnum << 22))
+#define LS2H_PCIE_PORT_REG_CTR0			0x0
+#define  LS2H_PCIE_REG_CTR0_BIT_LTSSM_EN	(1 << 3)
+#define  LS2H_PCIE_REG_CTR0_BIT_REQ_L1		(1 << 12)
+#define  LS2H_PCIE_REG_CTR0_BIT_RDY_L23		(1 << 13)
+#define LS2H_PCIE_PORT_REG_CTR1			0x4
+#define LS2H_PCIE_PORT_REG_STAT0		0x8
+#define LS2H_PCIE_PORT_REG_STAT1		0xc
+#define  LS2H_PCIE_REG_STAT1_MASK_LTSSM		0x0000003f
+#define  LS2H_PCIE_REG_STAT1_BIT_LINKUP		(1 << 6)
+#define LS2H_PCIE_PORT_REG_INTSTS		0x18
+#define LS2H_PCIE_PORT_REG_INTCLR		0x1c
+#define LS2H_PCIE_PORT_REG_INTMSK		0x20
+#define LS2H_PCIE_PORT_REG_CFGADDR		0x24
+#define LS2H_PCIE_PORT_REG_CTR_STAT		0x28
+#define  LS2H_PCIE_REG_CTR_STAT_BIT_ISX4	(1 << 26)
+#define  LS2H_PCIE_REG_CTR_STAT_BIT_ISRC	(1 << 27)
+#define LS2H_PCI_EXP_LNKCAP			0x7c
+#define LS2H_CLK_CTRL3_BIT_PEREF_EN(portnum)	(1 << (24 + portnum))
+
+/* ============== RS780/SBX00 registers =============== */
+
+#define SBX00_ACPI_IO_BASE 0x800
+#define SBX00_ACPI_IO_SIZE 0x100
+
+#define SBX00_PM_EVT_BLK       (SBX00_ACPI_IO_BASE + 0x00) /* 4 bytes */
+#define SBX00_PM_CNT_BLK       (SBX00_ACPI_IO_BASE + 0x04) /* 2 bytes */
+#define SBX00_PMA_CNT_BLK      (SBX00_ACPI_IO_BASE + 0x0F) /* 1 byte */
+#define SBX00_PM_TMR_BLK       (SBX00_ACPI_IO_BASE + 0x18) /* 4 bytes */
+#define SBX00_GPE0_BLK         (SBX00_ACPI_IO_BASE + 0x10) /* 8 bytes */
+#define SBX00_PM_END           (SBX00_ACPI_IO_BASE + 0x80)
+
+#define PM_INDEX        0xCD6
+#define PM_DATA         0xCD7
+#define PM2_INDEX       0xCD0
+#define PM2_DATA        0xCD1
+
+/* ============== Data structrues =============== */
+
+enum b_type { /* BoardType(BridgeType) */
+	LS2H   = 1,
+	RS780E = 2
+};
+
+struct platform_controller_hub {
+	int	type; /* BoardType(BridgeType) */
+	int 	pcidev_max_funcs;
+	void	(*early_config)(void);
+	void	(*init_irq)(void);
+	void	(*irq_dispatch)(void);
+	int	(*pcibios_map_irq)(const struct pci_dev *dev, u8 slot, u8 pin);
+	int	(*pcibios_dev_init)(struct pci_dev *dev);
+	void	(*pch_arch_initcall)(void);
+	void	(*pch_device_initcall)(void);
+};
+
+extern struct platform_controller_hub ls2h_pch;
+extern struct platform_controller_hub rs780_pch;
+extern struct platform_controller_hub *loongson_pch;
+
+extern struct pci_ops ls2h_pci_ops[4];
+extern void ls2h_init_irq(void);
+extern void ls2h_irq_dispatch(void);
+extern int ls2h_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
+
+extern struct pci_ops rs780_pci_ops;
+extern void rs780_init_irq(void);
+extern void rs780_irq_dispatch(void);
+extern int rs780_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
+
+#endif
diff --git a/arch/mips/include/asm/mach-loongson64/workarounds.h b/arch/mips/include/asm/mach-loongson64/workarounds.h
index 4cc5ca2fd..d666c7d7e 100644
--- a/arch/mips/include/asm/mach-loongson64/workarounds.h
+++ b/arch/mips/include/asm/mach-loongson64/workarounds.h
@@ -7,5 +7,6 @@
 #define WORKAROUND_LVDS_EC 	0x00000004
 #define WORKAROUND_LVDS_GPIO	0x00000008
 #define WORKAROUND_USB_TMCS	0x00000010
+#define WORKAROUND_PCIE_DMA	0x00000020
 
 #endif
diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
index 529dab855..3beee63d4 100644
--- a/arch/mips/kernel/cacheinfo.c
+++ b/arch/mips/kernel/cacheinfo.c
@@ -94,7 +94,9 @@ int populate_cache_leaves(unsigned int cpu)
 	if (c->tcache.waysize)
 		populate_cache(tcache, this_leaf, 3, CACHE_TYPE_UNIFIED);
 
+#ifndef CONFIG_CPU_LOONGSON3
 	this_cpu_ci->cpu_map_populated = true;
+#endif
 
 	return 0;
 }
diff --git a/arch/mips/loongson64/Kconfig b/arch/mips/loongson64/Kconfig
index 7e7e7f6d9..dcdc14128 100644
--- a/arch/mips/loongson64/Kconfig
+++ b/arch/mips/loongson64/Kconfig
@@ -92,6 +92,8 @@ config LOONGSON_MACH3X
 	select ZONE_DMA32
 	select DMA_MAYBE_COHERENT
 	select LEFI_FIRMWARE_INTERFACE
+	select USE_OF
+	select BUILTIN_DTB
 	help
 		Generic Loongson 3 family machines utilize the 3A/3B revision
 		of Loongson processor and RS780/SBX00 chipset.
@@ -113,12 +115,12 @@ config CS5536_MFGPT
 
 	  If unsure, say Yes.
 
-config RS780_HPET
-	bool "RS780/SBX00 HPET Timer"
+config LOONGSON_HPET
+	bool "Loongson HPET Timer"
 	depends on LOONGSON_MACH3X
 	select MIPS_EXTERNAL_TIMER
 	help
-	  This option enables the hpet timer of AMD RS780/SBX00.
+	  This option enables the hpet timer of LS2H or AMD RS780/SBX00.
 
 	  If you want to enable the Loongson3 CPUFreq Driver, Please enable
 	  this option at first, otherwise, You will get wrong system time.
diff --git a/arch/mips/loongson64/common/env.c b/arch/mips/loongson64/common/env.c
index 99da451fb..c742226ed 100644
--- a/arch/mips/loongson64/common/env.c
+++ b/arch/mips/loongson64/common/env.c
@@ -19,6 +19,7 @@
 #include <asm/dma-coherence.h>
 #include <loongson.h>
 #include <boot_param.h>
+#include <loongson-pch.h>
 #include <workarounds.h>
 
 u32 cpu_clock_freq;
@@ -35,6 +36,11 @@ unsigned long long smp_group[4];
 unsigned int has_systab = 0;
 unsigned long systab_addr;
 
+void *loongson_fdt_blob;
+struct platform_controller_hub dummy_pch;
+struct platform_controller_hub *loongson_pch;
+EXPORT_SYMBOL(loongson_pch);
+
 #define parse_even_earlier(res, option, p)				\
 do {									\
 	unsigned int tmp __maybe_unused;				\
@@ -67,6 +73,7 @@ void __init prom_init_env(void)
 	if (memsize == 0)
 		memsize = 256;
 
+	loongson_pch = &dummy_pch;
 	loongson_sysconf.nr_uarts = 1;
 
 	pr_info("memsize=%u, highmemsize=%u\n", memsize, highmemsize);
@@ -75,6 +82,7 @@ void __init prom_init_env(void)
 	struct boot_params *boot_p;
 	struct loongson_params *loongson_p;
 	struct system_loongson *esys;
+	struct board_devices *eboard;
 	struct efi_cpuinfo_loongson *ecpu;
 	struct irq_source_routing_table *eirq_source;
 
@@ -86,6 +94,8 @@ void __init prom_init_env(void)
 		((u64)loongson_p + loongson_p->system_offset);
 	ecpu = (struct efi_cpuinfo_loongson *)
 		((u64)loongson_p + loongson_p->cpu_offset);
+	eboard	= (struct board_devices *)
+		((u64)loongson_p + loongson_p->boarddev_table_offset);
 	eirq_source = (struct irq_source_routing_table *)
 		((u64)loongson_p + loongson_p->irq_offset);
 	loongson_memmap = (struct efi_memory_map_loongson *)
@@ -176,6 +186,19 @@ void __init prom_init_env(void)
 	hw_coherentio = !eirq_source->dma_noncoherent;
 	pr_info("BIOS configured I/O coherency: %s\n", hw_coherentio?"ON":"OFF");
 
+	if (strstr(eboard->name,"2H")) {
+		loongson_pch = &ls2h_pch;
+		loongson_sysconf.ec_sci_irq = 0x80;
+		loongson_fdt_blob = __dtb_loongson3_ls2h_begin;
+	}
+	else {
+		loongson_pch = &rs780_pch;
+		loongson_sysconf.ec_sci_irq = 0x07;
+		loongson_fdt_blob = __dtb_loongson3_rs780_begin;
+	}
+	if (esys->vers >= 2 && esys->of_dtb_addr)
+		loongson_fdt_blob = (void *)(esys->of_dtb_addr);
+
 	loongson_sysconf.restart_addr = boot_p->reset_system.ResetWarm;
 	loongson_sysconf.poweroff_addr = boot_p->reset_system.Shutdown;
 	loongson_sysconf.suspend_addr = boot_p->reset_system.DoSuspend;
diff --git a/arch/mips/loongson64/common/init.c b/arch/mips/loongson64/common/init.c
index 8e2047d04..70a18c971 100644
--- a/arch/mips/loongson64/common/init.c
+++ b/arch/mips/loongson64/common/init.c
@@ -11,6 +11,7 @@
 #include <asm/cacheflush.h>
 
 #include <loongson.h>
+#include <loongson-pch.h>
 
 /* Loongson CPU address windows config space base address */
 unsigned long __maybe_unused _loongson_addrwincfg_base;
@@ -49,6 +50,9 @@ void __init prom_init(void)
 	set_io_port_base((unsigned long)
 		ioremap(LOONGSON_PCIIO_BASE, LOONGSON_PCIIO_SIZE));
 
+	if (loongson_pch->early_config)
+		loongson_pch->early_config();
+
 #ifdef CONFIG_NUMA
 	prom_init_numa_memory();
 #else
diff --git a/arch/mips/loongson64/common/mem.c b/arch/mips/loongson64/common/mem.c
index 444fd93cd..bed1239d6 100644
--- a/arch/mips/loongson64/common/mem.c
+++ b/arch/mips/loongson64/common/mem.c
@@ -73,10 +73,14 @@ void __init prom_init_memory(void)
 
 		switch (mem_type) {
 		case SYSTEM_RAM_LOW:
+			loongson_sysconf.low_physmem_start =
+				loongson_memmap->map[i].mem_start;
 			memblock_add(loongson_memmap->map[i].mem_start,
 				(u64)loongson_memmap->map[i].mem_size << 20);
 			break;
 		case SYSTEM_RAM_HIGH:
+			loongson_sysconf.high_physmem_start =
+				loongson_memmap->map[i].mem_start;
 			memblock_add(loongson_memmap->map[i].mem_start,
 				(u64)loongson_memmap->map[i].mem_size << 20);
 			break;
diff --git a/arch/mips/loongson64/common/pci.c b/arch/mips/loongson64/common/pci.c
index c47bb7bf3..212b11f04 100644
--- a/arch/mips/loongson64/common/pci.c
+++ b/arch/mips/loongson64/common/pci.c
@@ -8,22 +8,23 @@
 #include <pci.h>
 #include <loongson.h>
 #include <boot_param.h>
+#include <loongson-pch.h>
 
-static struct resource loongson_pci_mem_resource = {
+static struct resource __maybe_unused loongson_pci_mem_resource = {
 	.name	= "pci memory space",
 	.start	= LOONGSON_PCI_MEM_START,
 	.end	= LOONGSON_PCI_MEM_END,
 	.flags	= IORESOURCE_MEM,
 };
 
-static struct resource loongson_pci_io_resource = {
+static struct resource __maybe_unused loongson_pci_io_resource = {
 	.name	= "pci io space",
 	.start	= LOONGSON_PCI_IO_START,
 	.end	= IO_SPACE_LIMIT,
 	.flags	= IORESOURCE_IO,
 };
 
-static struct pci_controller  loongson_pci_controller = {
+static struct pci_controller __maybe_unused loongson_pci_controller = {
 	.pci_ops	= &loongson_pci_ops,
 	.io_resource	= &loongson_pci_io_resource,
 	.mem_resource	= &loongson_pci_mem_resource,
@@ -31,7 +32,7 @@ static struct pci_controller  loongson_pci_controller = {
 	.io_offset	= 0x00000000UL,
 };
 
-static void __init setup_pcimap(void)
+static void __init __maybe_unused setup_pcimap(void)
 {
 	/*
 	 * local to PCI mapping for CPU accessing PCI space
@@ -74,21 +75,18 @@ static void __init setup_pcimap(void)
 #endif
 }
 
-extern int sbx00_acpi_init(void);
+extern int loongson_acpi_init(void);
 
 static int __init pcibios_init(void)
 {
+#ifndef CONFIG_LEFI_FIRMWARE_INTERFACE
 	setup_pcimap();
-
 	loongson_pci_controller.io_map_base = mips_io_port_base;
-#ifdef CONFIG_LEFI_FIRMWARE_INTERFACE
-	loongson_pci_mem_resource.start = loongson_sysconf.pci_mem_start_addr;
-	loongson_pci_mem_resource.end = loongson_sysconf.pci_mem_end_addr;
-#endif
 	register_pci_controller(&loongson_pci_controller);
+#endif
 
 #ifdef CONFIG_CPU_LOONGSON3
-	sbx00_acpi_init();
+	loongson_acpi_init();
 #endif
 
 	return 0;
diff --git a/arch/mips/loongson64/common/rtc.c b/arch/mips/loongson64/common/rtc.c
index 8d7628c0f..17c2dd911 100644
--- a/arch/mips/loongson64/common/rtc.c
+++ b/arch/mips/loongson64/common/rtc.c
@@ -9,6 +9,7 @@
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
 #include <linux/mc146818rtc.h>
+#include <loongson-pch.h>
 
 static struct resource loongson_rtc_resources[] = {
 	{
@@ -32,7 +33,14 @@ static struct platform_device loongson_rtc_device = {
 
 static int __init loongson_rtc_platform_init(void)
 {
-	platform_device_register(&loongson_rtc_device);
+	switch (loongson_pch->type) {
+	case LS2H:
+	case RS780E:
+		break;
+	default:
+		platform_device_register(&loongson_rtc_device);
+	}
+
 	return 0;
 }
 
diff --git a/arch/mips/loongson64/common/setup.c b/arch/mips/loongson64/common/setup.c
index bc2da4c14..1ec2c64c8 100644
--- a/arch/mips/loongson64/common/setup.c
+++ b/arch/mips/loongson64/common/setup.c
@@ -5,7 +5,10 @@
  */
 #include <linux/export.h>
 #include <linux/init.h>
+#include <linux/libfdt.h>
+#include <linux/of_fdt.h>
 
+#include <asm/prom.h>
 #include <asm/wbflush.h>
 #include <asm/bootinfo.h>
 
@@ -48,4 +51,16 @@ void __init plat_mem_setup(void)
 	conswitchp = &dummy_con;
 #endif
 #endif
+	if (loongson_fdt_blob)
+		__dt_setup_arch(loongson_fdt_blob);
+}
+
+#define NR_CELLS 6
+
+void __init device_tree_init(void)
+{
+	if (!initial_boot_params)
+		return;
+
+	unflatten_and_copy_device_tree();
 }
diff --git a/arch/mips/loongson64/common/time.c b/arch/mips/loongson64/common/time.c
index e78760ce4..440587d6d 100644
--- a/arch/mips/loongson64/common/time.c
+++ b/arch/mips/loongson64/common/time.c
@@ -18,7 +18,7 @@ void __init plat_time_init(void)
 	/* setup mips r4k timer */
 	mips_hpt_frequency = cpu_clock_freq / 2;
 
-#ifdef CONFIG_RS780_HPET
+#ifdef CONFIG_LOONGSON_HPET
 	setup_hpet_timer();
 #else
 	setup_mfgpt0_timer();
diff --git a/arch/mips/loongson64/loongson-3/Makefile b/arch/mips/loongson64/loongson-3/Makefile
index e8bf72290..7fb36d084 100644
--- a/arch/mips/loongson64/loongson-3/Makefile
+++ b/arch/mips/loongson64/loongson-3/Makefile
@@ -3,7 +3,7 @@
 # Makefile for Loongson-3 family machines
 #
 obj-y			+= irq.o cop2-ex.o platform.o acpi_init.o dma.o clock.o constant_timer.o ec_wpce775l.o \
-			   workarounds.o
+			   ls2h-irq.o ls2h-platform.o rs780-irq.o rs780-platform.o workarounds.o
 
 obj-$(CONFIG_SMP)	+= smp.o
 
@@ -11,6 +11,6 @@ obj-$(CONFIG_NUMA)	+= numa.o
 
 obj-$(CONFIG_SUSPEND)	+= pm.o sleep.o
 
-obj-$(CONFIG_RS780_HPET) += hpet.o
+obj-$(CONFIG_LOONGSON_HPET) += hpet.o
 
 obj-$(CONFIG_LOONGSON3_CPUAUTOPLUG) += loongson3_cpuautoplug.o
diff --git a/arch/mips/loongson64/loongson-3/acpi_init.c b/arch/mips/loongson64/loongson-3/acpi_init.c
index f8a08deb6..e0c3b0a37 100644
--- a/arch/mips/loongson64/loongson-3/acpi_init.c
+++ b/arch/mips/loongson64/loongson-3/acpi_init.c
@@ -1,28 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/io.h>
 #include <linux/init.h>
-#include <linux/pci.h>
 #include <linux/input.h>
 #include <linux/ioport.h>
 #include <linux/export.h>
 #include <linux/interrupt.h>
-
-#define SBX00_ACPI_IO_BASE 0x800
-#define SBX00_ACPI_IO_SIZE 0x100
-
-#define ACPI_PM_EVT_BLK         (SBX00_ACPI_IO_BASE + 0x00) /* 4 bytes */
-#define ACPI_PM_CNT_BLK         (SBX00_ACPI_IO_BASE + 0x04) /* 2 bytes */
-#define ACPI_PMA_CNT_BLK        (SBX00_ACPI_IO_BASE + 0x0F) /* 1 byte */
-#define ACPI_PM_TMR_BLK         (SBX00_ACPI_IO_BASE + 0x18) /* 4 bytes */
-#define ACPI_GPE0_BLK           (SBX00_ACPI_IO_BASE + 0x10) /* 8 bytes */
-#define ACPI_END                (SBX00_ACPI_IO_BASE + 0x80)
-
-#define PM_INDEX        0xCD6
-#define PM_DATA         0xCD7
-#define PM2_INDEX       0xCD0
-#define PM2_DATA        0xCD1
+#include <loongson-pch.h>
 
 static int acpi_irq;
+static void *gpe0_status_reg;
+static void *acpi_status_reg;
+static void *acpi_enable_reg;
+static void *acpi_control_reg;
 static struct input_dev *button;
 
 /*
@@ -76,12 +65,12 @@ static void acpi_hw_clear_status(void)
 	u16 value;
 
 	/* PMStatus: Clear WakeStatus/PwrBtnStatus */
-	value = inw(ACPI_PM_EVT_BLK);
+	value = readw(acpi_status_reg);
 	value |= (1 << 8 | 1 << 15);
-	outw(value, ACPI_PM_EVT_BLK);
+	writew(value, acpi_status_reg);
 
 	/* GPEStatus: Clear all generated events */
-	outl(inl(ACPI_GPE0_BLK), ACPI_GPE0_BLK);
+	writel(readl(gpe0_status_reg), gpe0_status_reg);
 }
 
 void acpi_sleep_prepare(void)
@@ -91,9 +80,11 @@ void acpi_sleep_prepare(void)
 	acpi_hw_clear_status();
 
 	/* Turn ON LED blink */
-	value = pm_ioread(0x7c);
-	value = (value & ~0xc) | 0x8;
-	pm_iowrite(0x7c, value);
+	if (loongson_pch->type == RS780E) {
+		value = pm_ioread(0x7c);
+		value = (value & ~0xc) | 0x8;
+		pm_iowrite(0x7c, value);
+	}
 }
 
 void acpi_sleep_complete(void)
@@ -103,9 +94,11 @@ void acpi_sleep_complete(void)
 	acpi_hw_clear_status();
 
 	/* Turn OFF LED blink */
-	value = pm_ioread(0x7c);
-	value |= 0xc;
-	pm_iowrite(0x7c, value);
+	if (loongson_pch->type == RS780E) {
+		value = pm_ioread(0x7c);
+		value |= 0xc;
+		pm_iowrite(0x7c, value);
+	}
 }
 
 static irqreturn_t acpi_int_routine(int irq, void *dev_id)
@@ -113,9 +106,9 @@ static irqreturn_t acpi_int_routine(int irq, void *dev_id)
 	u16 value;
 
 	/* PMStatus: Check PwrBtnStatus */
-	value = inw(ACPI_PM_EVT_BLK);
+	value = readw(acpi_status_reg);
 	if (value & (1 << 8)) {
-		outw(1 << 8, ACPI_PM_EVT_BLK);
+		writew(0x1 << 8, acpi_status_reg);
 		pr_info("Power Button pressed...\n");
 		input_report_key(button, KEY_POWER, 1);
 		input_sync(button);
@@ -130,17 +123,9 @@ static irqreturn_t acpi_int_routine(int irq, void *dev_id)
 static int __init power_button_init(void)
 {
 	int ret;
-	struct pci_dev *dev;
 
-	dev = pci_get_domain_bus_and_slot(0, 0, 0);
-	switch (dev->vendor) {
-	case PCI_VENDOR_ID_AMD:
-	case PCI_VENDOR_ID_ATI:
-		acpi_irq = 7;
-		break;
-	default:
+	if (!acpi_irq)
 		return -ENODEV;
-	}
 
 	button = input_allocate_device();
 	if (!button)
@@ -174,35 +159,35 @@ void acpi_registers_setup(void)
 {
 	u32 value;
 
+	if (loongson_pch->type != RS780E)
+		goto enable_power_button;
+
 	/* PM Status Base */
-	pm_iowrite(0x20, ACPI_PM_EVT_BLK & 0xff);
-	pm_iowrite(0x21, ACPI_PM_EVT_BLK >> 8);
+	pm_iowrite(0x20, SBX00_PM_EVT_BLK & 0xff);
+	pm_iowrite(0x21, SBX00_PM_EVT_BLK >> 8);
 
 	/* PM Control Base */
-	pm_iowrite(0x22, ACPI_PM_CNT_BLK & 0xff);
-	pm_iowrite(0x23, ACPI_PM_CNT_BLK >> 8);
+	pm_iowrite(0x22, SBX00_PM_CNT_BLK & 0xff);
+	pm_iowrite(0x23, SBX00_PM_CNT_BLK >> 8);
 
 	/* GPM Base */
-	pm_iowrite(0x28, ACPI_GPE0_BLK & 0xff);
-	pm_iowrite(0x29, ACPI_GPE0_BLK >> 8);
+	pm_iowrite(0x28, SBX00_GPE0_BLK & 0xff);
+	pm_iowrite(0x29, SBX00_GPE0_BLK >> 8);
 
 	/* ACPI End */
-	pm_iowrite(0x2e, ACPI_END & 0xff);
-	pm_iowrite(0x2f, ACPI_END >> 8);
+	pm_iowrite(0x2e, SBX00_PM_END & 0xff);
+	pm_iowrite(0x2f, SBX00_PM_END >> 8);
 
 	/* IO Decode: When AcpiDecodeEnable set, South-Bridge uses the contents
 	 * of the PM registers at index 0x20~0x2B to decode ACPI I/O address. */
 	pm_iowrite(0x0e, 1 << 3);
 
-	/* SCI_EN set */
-	outw(1, ACPI_PM_CNT_BLK);
-
 	/* Enable to generate SCI */
 	pm_iowrite(0x10, pm_ioread(0x10) | 1);
 
 	/* GPM3/GPM9 enable */
-	value = inl(ACPI_GPE0_BLK + 4);
-	outl(value | (1 << 14) | (1 << 22), ACPI_GPE0_BLK + 4);
+	value = inl(SBX00_GPE0_BLK + 4);
+	outl(value | (1 << 14) | (1 << 22), SBX00_GPE0_BLK + 4);
 
 	/* Set GPM9 as input */
 	pm_iowrite(0x8d, pm_ioread(0x8d) & (~(1 << 1)));
@@ -232,15 +217,40 @@ void acpi_registers_setup(void)
 	value |= ((1 << 5) | (1 << 1));
 	pm2_iowrite(0xf8, value);
 
+enable_power_button:
+	/* SCI_EN set */
+	value = readw(acpi_control_reg);
+	value |= 1;
+	writew(value, acpi_control_reg);
+
 	/* PMEnable: Enable PwrBtn */
-	value = inw(ACPI_PM_EVT_BLK + 2);
+	value = readw(acpi_enable_reg);
 	value |= 1 << 8;
-	outw(value, ACPI_PM_EVT_BLK + 2);
+	writew(value, acpi_enable_reg);
 }
 
-int __init sbx00_acpi_init(void)
+int __init loongson_acpi_init(void)
 {
-	register_acpi_resource();
+	switch (loongson_pch->type) {
+	case LS2H:
+		acpi_irq = LS2H_PCH_ACPI_IRQ;
+		acpi_control_reg = LS2H_PM_CNT_REG;
+		acpi_status_reg  = LS2H_PM_EVT_REG;
+		acpi_enable_reg  = LS2H_PM_ENA_REG;
+		gpe0_status_reg  = LS2H_GPE0_STS_REG;
+		break;
+	case RS780E:
+		acpi_irq = RS780_PCH_ACPI_IRQ;
+		acpi_control_reg = (void *)(mips_io_port_base + SBX00_PM_CNT_BLK + 0);
+		acpi_status_reg  = (void *)(mips_io_port_base + SBX00_PM_EVT_BLK + 0);
+		acpi_enable_reg  = (void *)(mips_io_port_base + SBX00_PM_EVT_BLK + 2);
+		gpe0_status_reg  = (void *)(mips_io_port_base + SBX00_GPE0_BLK   + 0);
+		register_acpi_resource();
+		break;
+	default:
+		return 0;
+	}
+
 	acpi_registers_setup();
 	acpi_hw_clear_status();
 
diff --git a/arch/mips/loongson64/loongson-3/dma.c b/arch/mips/loongson64/loongson-3/dma.c
index 24febcda5..2b5ea9bf6 100644
--- a/arch/mips/loongson64/loongson-3/dma.c
+++ b/arch/mips/loongson64/loongson-3/dma.c
@@ -1,6 +1,7 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/mm.h>
 #include <linux/init.h>
+#include <linux/sizes.h>
 #include <linux/dma-direct.h>
 #include <linux/dma-mapping.h>
 #include <linux/dma-noncoherent.h>
@@ -9,6 +10,7 @@
 
 #include <asm/bootinfo.h>
 #include <asm/dma-coherence.h>
+#include <loongson-pch.h>
 
 static inline void *dma_to_virt(struct device *dev, dma_addr_t dma_addr)
 {
@@ -39,13 +41,19 @@ static void loongson_dma_free_coherent(struct device *dev, size_t size,
 	dma_direct_free_pages(dev, size, vaddr, dma_handle, attrs);
 }
 
+#define PCIE_DMA_ALIGN 16
+
 static dma_addr_t loongson_dma_map_page(struct device *dev, struct page *page,
 				unsigned long offset, size_t size,
 				enum dma_data_direction dir,
 				unsigned long attrs)
 {
-	dma_addr_t daddr = dma_direct_map_page(dev, page, offset, size,
-					dir, attrs);
+	dma_addr_t daddr;
+
+	if (offset % PCIE_DMA_ALIGN)
+		attrs |= dev->dma_attrs;
+
+	daddr = dma_direct_map_page(dev, page, offset, size, dir, attrs);
 	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
 		dma_sync_virt(dma_to_virt(dev, daddr), size, dir);
 	mb();
@@ -69,6 +77,7 @@ static int loongson_dma_map_sg(struct device *dev, struct scatterlist *sgl,
 	int i, r;
 	struct scatterlist *sg;
 
+	attrs |= dev->dma_attrs;
 	r = dma_direct_map_sg(dev, sgl, nents, dir, attrs);
 	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC)) {
 		for_each_sg(sgl, sg, nents, i)
@@ -184,7 +193,23 @@ static int loongson_dma_supported(struct device *dev, u64 mask)
 	return (mask >= SZ_256M);
 }
 
-dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
+static dma_addr_t loongson_ls2h_phys_to_dma(struct device *dev, phys_addr_t paddr)
+{
+	dma_addr_t daddr;
+
+	daddr = (paddr < SZ_256M) ? paddr :
+		(paddr - loongson_sysconf.high_physmem_start + SZ_256M);
+
+	return (daddr < SZ_4G) ? daddr : -1ULL; /* DMA address should be below 4GB */
+}
+
+static phys_addr_t loongson_ls2h_dma_to_phys(struct device *dev, dma_addr_t daddr)
+{
+	return (daddr < SZ_256M) ? daddr :
+		(daddr + loongson_sysconf.high_physmem_start - SZ_256M);
+}
+
+static dma_addr_t loongson_rs780_phys_to_dma(struct device *dev, phys_addr_t paddr)
 {
 	/* We extract 2bit node id (bit 44~47, only bit 44~45 used now) from
 	 * Loongson-3's 48bit address space and embed it into 40bit */
@@ -192,7 +217,7 @@ dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
 	return ((nid << 44) ^ paddr) | (nid << 37);
 }
 
-phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t daddr)
+static phys_addr_t loongson_rs780_dma_to_phys(struct device *dev, dma_addr_t daddr)
 {
 	/* We extract 2bit node id (bit 44~47, only bit 44~45 used now) from
 	 * Loongson-3's 48bit address space and embed it into 40bit */
@@ -200,6 +225,22 @@ phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t daddr)
 	return ((nid << 37) ^ daddr) | (nid << 44);
 }
 
+struct loongson_addr_xlate_ops {
+	dma_addr_t (*phys_to_dma)(struct device *dev, phys_addr_t paddr);
+	phys_addr_t (*dma_to_phys)(struct device *dev, dma_addr_t daddr);
+};
+struct loongson_addr_xlate_ops xlate_ops;
+
+dma_addr_t __phys_to_dma(struct device *dev, phys_addr_t paddr)
+{
+	return xlate_ops.phys_to_dma(dev, paddr);
+}
+
+phys_addr_t __dma_to_phys(struct device *dev, dma_addr_t daddr)
+{
+	return xlate_ops.dma_to_phys(dev, daddr);
+}
+
 const struct dma_map_ops loongson_dma_ops = {
 	.alloc = loongson_dma_alloc_coherent,
 	.free = loongson_dma_free_coherent,
@@ -221,4 +262,15 @@ EXPORT_SYMBOL(loongson_dma_ops);
 void __init plat_swiotlb_setup(void)
 {
 	swiotlb_init(1);
+
+	switch (loongson_pch->type) {
+	case LS2H:
+		xlate_ops.phys_to_dma = loongson_ls2h_phys_to_dma;
+		xlate_ops.dma_to_phys = loongson_ls2h_dma_to_phys;
+		break;
+	case RS780E:
+		xlate_ops.phys_to_dma = loongson_rs780_phys_to_dma;
+		xlate_ops.dma_to_phys = loongson_rs780_dma_to_phys;
+		break;
+	}
 }
diff --git a/arch/mips/loongson64/loongson-3/hpet.c b/arch/mips/loongson64/loongson-3/hpet.c
index ed15430ad..4f9bf170a 100644
--- a/arch/mips/loongson64/loongson-3/hpet.c
+++ b/arch/mips/loongson64/loongson-3/hpet.c
@@ -8,6 +8,7 @@
 
 #include <asm/hpet.h>
 #include <asm/time.h>
+#include <loongson-pch.h>
 
 #define SMBUS_CFG_BASE		(loongson_sysconf.ht_control_base + 0x0300a000)
 #define SMBUS_PCI_REG40		0x40
@@ -17,6 +18,11 @@
 #define HPET_MIN_CYCLES		16
 #define HPET_MIN_PROG_DELTA	(HPET_MIN_CYCLES * 12)
 
+unsigned int hpet_freq;
+unsigned int hpet_t0_irq;
+unsigned int hpet_irq_flags;
+unsigned long long hpet_mmio_base;
+
 static DEFINE_SPINLOCK(hpet_lock);
 DEFINE_PER_CPU(struct clock_event_device, hpet_clockevent_device);
 
@@ -40,12 +46,12 @@ static void smbus_enable(int offset, int bit)
 
 static int hpet_read(int offset)
 {
-	return *(volatile unsigned int *)(HPET_MMIO_ADDR + offset);
+	return *(volatile unsigned int *)(hpet_mmio_base + offset);
 }
 
 static void hpet_write(int offset, int data)
 {
-	*(volatile unsigned int *)(HPET_MMIO_ADDR + offset) = data;
+	*(volatile unsigned int *)(hpet_mmio_base + offset) = data;
 }
 
 static void hpet_start_counter(void)
@@ -91,12 +97,14 @@ static int hpet_set_state_periodic(struct clock_event_device *evt)
 	pr_info("set clock event to periodic mode!\n");
 	/* stop counter */
 	hpet_stop_counter();
+	hpet_reset_counter();
+	hpet_write(HPET_T0_CMP, 0);
 
 	/* enables the timer0 to generate a periodic interrupt */
 	cfg = hpet_read(HPET_T0_CFG);
 	cfg &= ~HPET_TN_LEVEL;
 	cfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC | HPET_TN_SETVAL |
-		HPET_TN_32BIT;
+		HPET_TN_32BIT | hpet_irq_flags;
 	hpet_write(HPET_T0_CFG, cfg);
 
 	/* set the comparator */
@@ -194,30 +202,19 @@ static struct irqaction hpet_irq = {
 };
 
 /*
- * hpet address assignation and irq setting should be done in bios.
- * but pmon don't do this, we just setup here directly.
- * The operation under is normal. unfortunately, hpet_setup process
- * is before pci initialize.
- *
- * {
- *	struct pci_dev *pdev;
- *
- *	pdev = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
- *	pci_write_config_word(pdev, SMBUS_PCI_REGB4, HPET_ADDR);
- *
- *	...
- * }
+ * HPET address assignation and irq setting should be done in bios.
+ * But, sometimes bios don't do this, we just setup here directly.
  */
 static void hpet_setup(void)
 {
-	/* set hpet base address */
-	smbus_write(SMBUS_PCI_REGB4, HPET_ADDR);
-
-	/* enable decoding of access to HPET MMIO*/
-	smbus_enable(SMBUS_PCI_REG40, (1 << 28));
-
-	/* HPET irq enable */
-	smbus_enable(SMBUS_PCI_REG64, (1 << 10));
+	if (loongson_pch->type == RS780E) {
+		/* set hpet base address */
+		smbus_write(SMBUS_PCI_REGB4, HPET_ADDR);
+		/* enable decoding of access to HPET MMIO*/
+		smbus_enable(SMBUS_PCI_REG40, (1 << 28));
+		/* HPET irq enable */
+		smbus_enable(SMBUS_PCI_REG64, (1 << 10));
+	}
 
 	hpet_enable_legacy_int();
 }
@@ -227,6 +224,21 @@ void __init setup_hpet_timer(void)
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *cd;
 
+	switch (loongson_pch->type) {
+	case LS2H:
+		hpet_freq = LS2H_HPET_FREQ;
+		hpet_t0_irq = LS2H_HPET_T0_IRQ;
+		hpet_mmio_base = LS2H_HPET_BASE;
+		hpet_irq_flags = HPET_TN_LEVEL;
+		break;
+	case RS780E:
+		hpet_freq = RS780_HPET_FREQ;
+		hpet_t0_irq = RS780_HPET_T0_IRQ;
+		hpet_mmio_base = RS780_HPET_BASE;
+		hpet_irq_flags = 0;
+		break;
+	}
+
 	hpet_setup();
 
 	cd = &per_cpu(hpet_clockevent_device, cpu);
@@ -238,16 +250,16 @@ void __init setup_hpet_timer(void)
 	cd->set_state_oneshot = hpet_set_state_oneshot;
 	cd->tick_resume = hpet_tick_resume;
 	cd->set_next_event = hpet_next_event;
-	cd->irq = HPET_T0_IRQ;
+	cd->irq = hpet_t0_irq;
 	cd->cpumask = cpumask_of(cpu);
-	clockevent_set_clock(cd, HPET_FREQ);
+	clockevent_set_clock(cd, hpet_freq);
 	cd->max_delta_ns = clockevent_delta2ns(0x7fffffff, cd);
 	cd->max_delta_ticks = 0x7fffffff;
 	cd->min_delta_ns = clockevent_delta2ns(HPET_MIN_PROG_DELTA, cd);
 	cd->min_delta_ticks = HPET_MIN_PROG_DELTA;
 
 	clockevents_register_device(cd);
-	setup_irq(HPET_T0_IRQ, &hpet_irq);
+	setup_irq(hpet_t0_irq, &hpet_irq);
 	pr_info("hpet clock event device register\n");
 }
 
@@ -282,8 +294,8 @@ static struct clocksource csrc_hpet = {
 
 int __init init_hpet_clocksource(void)
 {
-	csrc_hpet.mult = clocksource_hz2mult(HPET_FREQ, csrc_hpet.shift);
-	return clocksource_register_hz(&csrc_hpet, HPET_FREQ);
+	csrc_hpet.mult = clocksource_hz2mult(hpet_freq, csrc_hpet.shift);
+	return clocksource_register_hz(&csrc_hpet, hpet_freq);
 }
 
 arch_initcall(init_hpet_clocksource);
diff --git a/arch/mips/loongson64/loongson-3/irq.c b/arch/mips/loongson64/loongson-3/irq.c
index 5605061f5..1dc689171 100644
--- a/arch/mips/loongson64/loongson-3/irq.c
+++ b/arch/mips/loongson64/loongson-3/irq.c
@@ -1,21 +1,17 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <loongson.h>
 #include <irq.h>
-#include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/irqchip.h>
+#include <linux/interrupt.h>
 
 #include <asm/irq_cpu.h>
 #include <asm/i8259.h>
 #include <asm/mipsregs.h>
 
+#include <loongson-pch.h>
 #include "smp.h"
 
-extern void loongson3_send_irq_by_ipi(int cpu, int irqs);
-
-unsigned int irq_cpu[16] = {[0 ... 15] = -1};
-unsigned int ht_irq[] = {0, 1, 3, 4, 5, 6, 7, 8, 12, 14, 15};
-unsigned int local_irq = 1<<0 | 1<<1 | 1<<2 | 1<<7 | 1<<8 | 1<<12;
-
 int plat_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity,
 			  bool force)
 {
@@ -36,44 +32,36 @@ int plat_set_irq_affinity(struct irq_data *d, const struct cpumask *affinity,
 	return IRQ_SET_MASK_OK_NOCOPY;
 }
 
-static void ht_irqdispatch(void)
+static DECLARE_BITMAP(ipi_irq_in_use, NR_DIRQS);
+unsigned int loongson_ipi_irq2pos[NR_IRQS] = { [0 ... NR_IRQS-1] = -1 };
+unsigned int loongson_ipi_pos2irq[NR_DIRQS] = { [0 ... NR_DIRQS-1] = -1 };
+
+void create_ipi_dirq(unsigned int irq)
 {
-	unsigned int i, irq;
-	struct irq_data *irqd;
-	struct cpumask affinity;
-
-	irq = LOONGSON_HT1_INT_VECTOR(0);
-	LOONGSON_HT1_INT_VECTOR(0) = irq; /* Acknowledge the IRQs */
-
-	for (i = 0; i < ARRAY_SIZE(ht_irq); i++) {
-		if (!(irq & (0x1 << ht_irq[i])))
-			continue;
-
-		/* handled by local core */
-		if (local_irq & (0x1 << ht_irq[i])) {
-			do_IRQ(ht_irq[i]);
-			continue;
-		}
-
-		irqd = irq_get_irq_data(ht_irq[i]);
-		cpumask_and(&affinity, irqd->common->affinity, cpu_active_mask);
-		if (cpumask_empty(&affinity)) {
-			do_IRQ(ht_irq[i]);
-			continue;
-		}
-
-		irq_cpu[ht_irq[i]] = cpumask_next(irq_cpu[ht_irq[i]], &affinity);
-		if (irq_cpu[ht_irq[i]] >= nr_cpu_ids)
-			irq_cpu[ht_irq[i]] = cpumask_first(&affinity);
-
-		if (irq_cpu[ht_irq[i]] == 0) {
-			do_IRQ(ht_irq[i]);
-			continue;
-		}
-
-		/* balanced by other cores */
-		loongson3_send_irq_by_ipi(irq_cpu[ht_irq[i]], (0x1 << ht_irq[i]));
-	}
+	int pos;
+
+	pos = find_first_zero_bit(ipi_irq_in_use, NR_DIRQS);
+
+	if (pos == NR_DIRQS)
+		return;
+
+	loongson_ipi_pos2irq[pos] = irq;
+	loongson_ipi_irq2pos[irq] = pos;
+	set_bit(pos, ipi_irq_in_use);
+}
+
+void destroy_ipi_dirq(unsigned int irq)
+{
+	int pos;
+
+	pos = loongson_ipi_irq2pos[irq];
+
+	if (pos < 0)
+		return;
+
+	loongson_ipi_irq2pos[irq] = -1;
+	loongson_ipi_pos2irq[pos] = -1;
+	clear_bit(pos, ipi_irq_in_use);
 }
 
 #define UNUSED_IPS (CAUSEF_IP5 | CAUSEF_IP4 | CAUSEF_IP1 | CAUSEF_IP0)
@@ -87,7 +75,7 @@ void mach_irq_dispatch(unsigned int pending)
 		loongson3_ipi_interrupt(NULL);
 #endif
 	if (pending & CAUSEF_IP3)
-		ht_irqdispatch();
+		loongson_pch->irq_dispatch();
 	if (pending & CAUSEF_IP2)
 		do_IRQ(LOONGSON_UART_IRQ);
 	if (pending & UNUSED_IPS) {
@@ -109,35 +97,12 @@ static struct irq_chip loongson_irq_chip = {
 	.irq_eoi	= unmask_loongson_irq,
 };
 
-void irq_router_init(void)
-{
-	int i;
-
-	/* route LPC int to cpu core0 int 0 */
-	LOONGSON_INT_ROUTER_LPC =
-		LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 0);
-	/* route HT1 int0 ~ int7 to cpu core0 INT1*/
-	for (i = 0; i < 8; i++)
-		LOONGSON_INT_ROUTER_HT1(i) =
-			LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 1);
-	/* enable HT1 interrupt */
-	LOONGSON_HT1_INTN_EN(0) = 0xffffffff;
-	/* enable router interrupt intenset */
-	LOONGSON_INT_ROUTER_INTENSET =
-		LOONGSON_INT_ROUTER_INTEN | (0xffff << 16) | 0x1 << 10;
-}
-
 void __init mach_init_irq(void)
 {
-	struct irq_chip *chip;
-
 	clear_c0_status(ST0_IM | ST0_BEV);
 
-	irq_router_init();
-	mips_cpu_irq_init();
-	init_i8259_irqs();
-	chip = irq_get_chip(I8259A_IRQ_BASE);
-	chip->irq_set_affinity = plat_set_irq_affinity;
+	irqchip_init();
+	loongson_pch->init_irq();
 
 	irq_set_chip_and_handler(LOONGSON_UART_IRQ,
 			&loongson_irq_chip, handle_percpu_irq);
diff --git a/arch/mips/loongson64/loongson-3/ls2h-irq.c b/arch/mips/loongson64/loongson-3/ls2h-irq.c
new file mode 100644
index 000000000..463655528
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/ls2h-irq.c
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Copyright (C) 2013, Loongson Technology Corporation Limited, Inc.
+ *  Copyright (C) 2014-2017, Lemote, Inc.
+ */
+#include <linux/init.h>
+#include <linux/cpumask.h>
+#include <linux/irqchip.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/irq_cpu.h>
+#include <asm/mipsregs.h>
+#include <asm/smp.h>
+#include <asm/delay.h>
+#include <irq.h>
+#include <loongson.h>
+#include <boot_param.h>
+#include <loongson-pch.h>
+
+static unsigned int irq_cpu[NR_IRQS] = {[0 ... NR_IRQS-1] = -1};
+
+struct intctl_regs {
+	volatile u32 int_isr;
+	volatile u32 int_en;
+	volatile u32 int_set;
+	volatile u32 int_clr;
+	volatile u32 int_pol;
+	volatile u32 int_edge;
+};
+static struct intctl_regs volatile *int_ctrl_regs =
+	(struct intctl_regs volatile *)(CKSEG1ADDR(LS2H_INT_REG_BASE));
+
+static DEFINE_RAW_SPINLOCK(pch_irq_lock);
+
+static void mask_pch_irq(struct irq_data *d)
+{
+	int irq_nr;
+	unsigned long flags;
+
+	if (d->irq < 16) {
+		local_irq_save(flags);
+		writel(readl(LS2H_LPC_INT_ENA) & ~(0x1 << (d->irq)), LS2H_LPC_INT_ENA);
+		local_irq_restore(flags);
+	} else {
+		raw_spin_lock_irqsave(&pch_irq_lock, flags);
+		irq_nr = d->irq - LS2H_PCH_IRQ_BASE;
+		(int_ctrl_regs + (irq_nr >> 5))->int_en &= ~(1 << (irq_nr & 0x1f));
+		raw_spin_unlock_irqrestore(&pch_irq_lock, flags);
+	}
+}
+
+static void unmask_pch_irq(struct irq_data *d)
+{
+	int irq_nr;
+	unsigned long flags;
+
+	if (d->irq < 16) {
+		local_irq_save(flags);
+		writel(readl(LS2H_LPC_INT_ENA) | (0x1 << (d->irq)), LS2H_LPC_INT_ENA);
+		local_irq_restore(flags);
+	} else {
+		raw_spin_lock_irqsave(&pch_irq_lock, flags);
+		irq_nr = d->irq - LS2H_PCH_IRQ_BASE;
+		(int_ctrl_regs + (irq_nr >> 5))->int_en |= (1 << (irq_nr & 0x1f));
+		raw_spin_unlock_irqrestore(&pch_irq_lock, flags);
+	}
+}
+
+static struct irq_chip pch_irq_chip = {
+	.name			= "Loongson",
+	.irq_mask		= mask_pch_irq,
+	.irq_unmask		= unmask_pch_irq,
+	.irq_set_affinity	= plat_set_irq_affinity,
+	.flags			= IRQCHIP_MASK_ON_SUSPEND,
+};
+
+#define LPC_OFFSET 13
+
+/* Handle LPC IRQs */
+static irqreturn_t lpc_irq_dispatch(int irq, void *data)
+{
+	int irqs;
+
+	irqs = readl(LS2H_LPC_INT_ENA) & readl(LS2H_LPC_INT_STS);
+	if (!irqs)
+		return IRQ_NONE;
+
+	while ((irq = ffs(irqs))) {
+		do_IRQ(irq - 1);
+		irqs &= ~(1 << (irq - 1));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction lpc_irqaction = {
+	.name = "lpc",
+	.flags = IRQF_NO_THREAD,
+	.handler = lpc_irq_dispatch,
+};
+
+void ls2h_irq_dispatch(void)
+{
+	unsigned long flags;
+	struct irq_data *irqd;
+	struct cpumask affinity;
+	unsigned int i, irq, inten, intstatus;
+
+	for (i = 0; i < 3; i++) {
+		raw_spin_lock_irqsave(&pch_irq_lock, flags);
+		inten = (int_ctrl_regs + i)->int_en;
+		intstatus = (int_ctrl_regs + i)->int_isr;
+		(int_ctrl_regs + i)->int_en = (inten & ~intstatus);
+		raw_spin_unlock_irqrestore(&pch_irq_lock, flags);
+
+		if (intstatus == 0)
+			continue;
+
+		/* Handle normal IRQs */
+		while (intstatus) {
+			irq = ffs(intstatus);
+			intstatus &= ~(1 << (irq-1));
+			irq = LS2H_PCH_IRQ_BASE + i * 32 + irq - 1;
+
+			/* handled by local core */
+			if (loongson_ipi_irq2pos[irq] == -1) {
+				do_IRQ(irq);
+				continue;
+			}
+
+			irqd = irq_get_irq_data(irq);
+			cpumask_and(&affinity, irqd->common->affinity, cpu_active_mask);
+			if (cpumask_empty(&affinity)) {
+				do_IRQ(irq);
+				continue;
+			}
+
+			irq_cpu[irq] = cpumask_next(irq_cpu[irq], &affinity);
+			if (irq_cpu[irq] >= nr_cpu_ids)
+				irq_cpu[irq] = cpumask_first(&affinity);
+
+			if (irq_cpu[irq] == 0) {
+				do_IRQ(irq);
+				continue;
+			}
+
+			/* balanced by other cores */
+			loongson3_send_irq_by_ipi(irq_cpu[irq], (0x1 << (loongson_ipi_irq2pos[irq])));
+		}
+	}
+}
+
+void ls2h_init_irq(void)
+{
+	int i;
+
+	/* Route INTn0 to Core0 INT1 */
+	LOONGSON_INT_ROUTER_ENTRY(0) = LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 1);
+
+	/* Route the LPC interrupt to Core0 INT0 */
+	LOONGSON_INT_ROUTER_LPC = LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 0);
+
+	/* Enable UART and INT0 interrupts */
+	LOONGSON_INT_ROUTER_INTENSET = (0x1 << 10) | (1 << 0);
+
+	/* uart, keyboard, and mouse are active high */
+	(int_ctrl_regs + 0)->int_edge	= 0x00000000;
+	(int_ctrl_regs + 0)->int_pol	= 0xff7fffff;
+	(int_ctrl_regs + 0)->int_en	= 0x00002000;
+	(int_ctrl_regs + 0)->int_clr	= 0xffffffff;
+
+	(int_ctrl_regs + 1)->int_edge	= 0x00000000;
+	(int_ctrl_regs + 1)->int_pol	= 0xfeffffff;
+	(int_ctrl_regs + 1)->int_en	= 0x00000000;
+	(int_ctrl_regs + 1)->int_clr	= 0xffffffff;
+
+	(int_ctrl_regs + 2)->int_edge	= 0x00000000;
+	(int_ctrl_regs + 2)->int_pol	= 0xfffffffe;
+	(int_ctrl_regs + 2)->int_en	= 0x00000000;
+	(int_ctrl_regs + 2)->int_clr	= 0xffffffff;
+
+	/* Enable the LPC interrupt */
+	writel(0x80000000, LS2H_LPC_INT_CTL);
+	/* Clear all 18-bit interrupt bits */
+	writel(0x3ffff, LS2H_LPC_INT_CLR);
+
+	for (i = 0; i < NR_IRQS; i++)
+		loongson_ipi_irq2pos[i] = -1;
+	for (i = 0; i < NR_DIRQS; i++)
+		loongson_ipi_pos2irq[i] = -1;
+	create_ipi_dirq(LS2H_PCH_SATA_IRQ);
+	create_ipi_dirq(LS2H_PCH_GMAC0_IRQ);
+	create_ipi_dirq(LS2H_PCH_GMAC1_IRQ);
+	create_ipi_dirq(LS2H_PCH_PCIE_PORT0_IRQ);
+	create_ipi_dirq(LS2H_PCH_PCIE_PORT1_IRQ);
+	create_ipi_dirq(LS2H_PCH_PCIE_PORT2_IRQ);
+	create_ipi_dirq(LS2H_PCH_PCIE_PORT3_IRQ);
+	create_ipi_dirq(LS2H_PCH_OTG_IRQ);
+	create_ipi_dirq(LS2H_PCH_EHCI_IRQ);
+	create_ipi_dirq(LS2H_PCH_OHCI_IRQ);
+}
+
+int __init ls2h_irq_of_init(struct device_node *node, struct device_node *parent)
+{
+	u32 i;
+
+	irq_domain_add_legacy(node, 160, LS2H_PCH_IRQ_BASE,
+			LS2H_PCH_IRQ_BASE, &irq_domain_simple_ops, NULL);
+
+	irq_set_chip_and_handler(1, &pch_irq_chip, handle_level_irq);
+	irq_set_chip_and_handler(4, &pch_irq_chip, handle_level_irq);
+	irq_set_chip_and_handler(5, &pch_irq_chip, handle_level_irq);
+	irq_set_chip_and_handler(12, &pch_irq_chip, handle_level_irq);
+
+	for (i = LS2H_PCH_IRQ_BASE; i < LS2H_PCH_LAST_IRQ; i++)
+		irq_set_chip_and_handler(i, &pch_irq_chip, handle_level_irq);
+	setup_irq(LS2H_PCH_IRQ_BASE + LPC_OFFSET, &lpc_irqaction);
+
+	return 0;
+}
+IRQCHIP_DECLARE(plat_intc, "loongson,ls2h-interrupt-controller", ls2h_irq_of_init);
diff --git a/arch/mips/loongson64/loongson-3/ls2h-platform.c b/arch/mips/loongson64/loongson-3/ls2h-platform.c
new file mode 100644
index 000000000..bbe972872
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/ls2h-platform.c
@@ -0,0 +1,200 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Copyright (C) 2013, Loongson Technology Corporation Limited, Inc.
+ *  Copyright (C) 2014-2017, Lemote, Inc.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#include <irq.h>
+#include <pci.h>
+#include <boot_param.h>
+#include <loongson-pch.h>
+
+/*
+ * PCI Controller
+ */
+static int nr_pci_ports;
+
+static struct resource pci_mem_resource[4] = {
+	{
+		.name	= "pci memory space",
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "pci memory space",
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "pci memory space",
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "pci memory space",
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct resource pci_io_resource[4] = {
+	{
+		.name	= "pci io space",
+		.flags	= IORESOURCE_IO,
+	},
+	{
+		.name	= "pci io space",
+		.flags	= IORESOURCE_IO,
+	},
+	{
+		.name	= "pci io space",
+		.flags	= IORESOURCE_IO,
+	},
+	{
+		.name	= "pci io space",
+		.flags	= IORESOURCE_IO,
+	}
+};
+
+static struct pci_controller ls2h_pci_controller[4] = {
+	{
+		.pci_ops	= &ls2h_pci_ops[0],
+		.mem_resource	= &pci_mem_resource[0],
+		.io_resource	= &pci_io_resource[0],
+		.mem_offset	= 0x00000000UL,
+		.io_offset	= 0x00000000UL,
+		.io_map_base	= 0x90000e0018000000UL,
+	},
+	{
+		.pci_ops	= &ls2h_pci_ops[1],
+		.mem_resource	= &pci_mem_resource[1],
+		.io_resource	= &pci_io_resource[1],
+		.mem_offset	= 0x00000000UL,
+		.io_offset	= 0x00000000UL,
+		.io_map_base	= 0x90000e0018000000UL,
+	},
+	{
+		.pci_ops	= &ls2h_pci_ops[2],
+		.mem_resource	= &pci_mem_resource[2],
+		.io_resource	= &pci_io_resource[2],
+		.mem_offset	= 0x00000000UL,
+		.io_offset	= 0x00000000UL,
+		.io_map_base	= 0x90000e0018000000UL,
+	},
+	{
+		.pci_ops	= &ls2h_pci_ops[3],
+		.mem_resource	= &pci_mem_resource[3],
+		.io_resource	= &pci_io_resource[3],
+		.mem_offset	= 0x00000000UL,
+		.io_offset	= 0x00000000UL,
+		.io_map_base	= 0x90000e0018000000UL,
+	}
+};
+
+static void en_ref_clock(void)
+{
+	unsigned int data;
+
+	data = readl(LS2H_CLK_CTRL3_REG);
+	data |= (LS2H_CLK_CTRL3_BIT_PEREF_EN(0)
+		 | LS2H_CLK_CTRL3_BIT_PEREF_EN(1)
+		 | LS2H_CLK_CTRL3_BIT_PEREF_EN(2)
+		 | LS2H_CLK_CTRL3_BIT_PEREF_EN(3));
+	writel(data, LS2H_CLK_CTRL3_REG);
+}
+
+static int pcie_is_x4_mode(void)
+{
+	u32 data = readl((u32 *)(LS2H_PCIE_PORT_REG_BASE(0) | LS2H_PCIE_PORT_REG_CTR_STAT));
+
+	return data & LS2H_PCIE_REG_CTR_STAT_BIT_ISX4;
+}
+
+static void pcie_port_init(int port)
+{
+	unsigned int *reg, data;
+
+	reg = (void *)(LS2H_PCIE_PORT_REG_BASE(port) | LS2H_PCIE_PORT_REG_CTR0);
+	writel(0x00ff204c, reg);
+
+	reg = (void *)(LS2H_PCIE_PORT_HEAD_BASE(port) | PCI_CLASS_REVISION);
+	data = (readl(reg) & 0xffff) | (PCI_CLASS_BRIDGE_PCI << 16);
+	writel(data, reg);
+
+	reg = (void *)(LS2H_PCIE_PORT_HEAD_BASE(port) | LS2H_PCI_EXP_LNKCAP);
+	data = (readl(reg) & (~0xf)) | 0x1;
+	writel(data, reg);
+}
+
+static void ls2h_early_config(void)
+{
+	u32 i, val;
+
+	/*
+	 * Loongson-2H chip_config0: 0x1fd00200
+	 * bit[5]: 	Loongson-2H bridge mode,0: disable      1: enable
+	 * bit[4]:	ac97/hda select,	0: ac97		1: hda
+	 * bit[14]:	host/otg select,	0: host         1: otg
+	 * bit[26]:	usb reset,		0: enable       1: disable
+	 */
+	val = readl(LS2H_CHIP_CFG0_REG);
+	writel(val | (1 << 5) | (1 << 4) | (1 << 14) | (1 << 26), LS2H_CHIP_CFG0_REG);
+
+	val = readl(LS2H_GPIO_OE_REG);
+	writel(val | (1 << 0), LS2H_GPIO_OE_REG);
+
+	en_ref_clock();
+
+	val = readl((void *)(LS2H_PCIE_PORT_REG_BASE(0) | LS2H_PCIE_PORT_REG_CTR_STAT));
+	val |= LS2H_PCIE_REG_CTR_STAT_BIT_ISRC;  /* Enable RC mode */
+	writel(val, (void *)(LS2H_PCIE_PORT_REG_BASE(0) | LS2H_PCIE_PORT_REG_CTR_STAT));
+
+	if (pcie_is_x4_mode())
+		nr_pci_ports = 1;
+	else
+		nr_pci_ports = 4;
+
+	for (i = 0; i < nr_pci_ports; i++)
+		pcie_port_init(i);
+}
+
+static void __init ls2h_arch_initcall(void)
+{
+	u64 i, pci_mem_size;
+
+	if (!loongson_sysconf.pci_mem_start_addr)
+		loongson_sysconf.pci_mem_start_addr = LOONGSON_PCI_MEM_START;
+	if (!loongson_sysconf.pci_mem_end_addr)
+		loongson_sysconf.pci_mem_end_addr = LOONGSON_PCI_MEM_START + 0x40000000UL - 1;
+	pci_mem_size = loongson_sysconf.pci_mem_end_addr - loongson_sysconf.pci_mem_start_addr + 1;
+
+	ioport_resource.end = 0xffffffff;
+	for (i = 0; i < nr_pci_ports; i++) {
+		pci_io_resource[i].start = 0x400000*i + 0x100000;
+		pci_io_resource[i].end   = 0x400000*i + 0x10ffff;
+		pci_mem_resource[i].start =
+			loongson_sysconf.pci_mem_start_addr + pci_mem_size*i/nr_pci_ports;
+		pci_mem_resource[i].end   =
+			loongson_sysconf.pci_mem_start_addr + pci_mem_size*(i+1)/nr_pci_ports - 1;
+		register_pci_controller(&ls2h_pci_controller[i]);
+	}
+}
+
+static void __init ls2h_device_initcall(void)
+{
+}
+
+struct platform_controller_hub ls2h_pch = {
+	.type			= LS2H,
+	.pcidev_max_funcs 	= 1,
+	.early_config		= ls2h_early_config,
+	.init_irq		= ls2h_init_irq,
+	.irq_dispatch		= ls2h_irq_dispatch,
+	.pch_arch_initcall	= ls2h_arch_initcall,
+	.pch_device_initcall	= ls2h_device_initcall,
+};
diff --git a/arch/mips/loongson64/loongson-3/numa.c b/arch/mips/loongson64/loongson-3/numa.c
index 7a152c666..6696c8aca 100644
--- a/arch/mips/loongson64/loongson-3/numa.c
+++ b/arch/mips/loongson64/loongson-3/numa.c
@@ -137,6 +137,9 @@ static void __init szmem(unsigned int node)
 
 		switch (mem_type) {
 		case SYSTEM_RAM_LOW:
+			if (node_id == 0)
+				loongson_sysconf.low_physmem_start =
+					loongson_memmap->map[i].mem_start;
 			start_pfn = ((node_id << 44) + mem_start) >> PAGE_SHIFT;
 			node_psize = (mem_size << 20) >> PAGE_SHIFT;
 			end_pfn  = start_pfn + node_psize;
@@ -149,6 +152,9 @@ static void __init szmem(unsigned int node)
 				PFN_PHYS(end_pfn - start_pfn), node);
 			break;
 		case SYSTEM_RAM_HIGH:
+			if (node_id == 0)
+				loongson_sysconf.high_physmem_start =
+					loongson_memmap->map[i].mem_start;
 			start_pfn = ((node_id << 44) + mem_start) >> PAGE_SHIFT;
 			node_psize = (mem_size << 20) >> PAGE_SHIFT;
 			end_pfn  = start_pfn + node_psize;
diff --git a/arch/mips/loongson64/loongson-3/platform.c b/arch/mips/loongson64/loongson-3/platform.c
index a7899c6fd..533973d76 100644
--- a/arch/mips/loongson64/loongson-3/platform.c
+++ b/arch/mips/loongson64/loongson-3/platform.c
@@ -13,6 +13,7 @@
 #include <linux/platform_device.h>
 #include <asm/bootinfo.h>
 #include <boot_param.h>
+#include <loongson-pch.h>
 #include <loongson_hwmon.h>
 #include <workarounds.h>
 
@@ -81,6 +82,8 @@ static int __init loongson3_platform_init(void)
 	int i;
 	struct platform_device *pdev;
 
+	loongson_pch->pch_arch_initcall();
+
 	if (loongson_sysconf.ecname[0] != '\0')
 		platform_device_register_simple(loongson_sysconf.ecname, -1, NULL, 0);
 
@@ -106,4 +109,12 @@ static int __init loongson3_platform_init(void)
 	return 0;
 }
 
+static int __init loongson3_device_init(void)
+{
+	loongson_pch->pch_device_initcall();
+
+	return 0;
+}
+
 arch_initcall(loongson3_platform_init);
+device_initcall(loongson3_device_init);
diff --git a/arch/mips/loongson64/loongson-3/pm.c b/arch/mips/loongson64/loongson-3/pm.c
index ef0b9cfc4..988b4fe35 100644
--- a/arch/mips/loongson64/loongson-3/pm.c
+++ b/arch/mips/loongson64/loongson-3/pm.c
@@ -24,8 +24,8 @@
 
 #include <loongson.h>
 #include <mc146818rtc.h>
+#include <loongson-pch.h>
 
-extern void irq_router_init(void);
 extern void acpi_sleep_prepare(void);
 extern void acpi_sleep_complete(void);
 extern void acpi_registers_setup(void);
@@ -131,7 +131,8 @@ void mach_resume(void)
 		write_c0_userlocal(loongson_regs.userlocal);
 	}
 
-	irq_router_init();
+	loongson_pch->early_config();
+	loongson_pch->init_irq();
 	acpi_registers_setup();
 	acpi_sleep_complete();
 }
diff --git a/arch/mips/loongson64/loongson-3/rs780-irq.c b/arch/mips/loongson64/loongson-3/rs780-irq.c
new file mode 100644
index 000000000..b7b93b344
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/rs780-irq.c
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Copyright (C) 2013, Loongson Technology Corporation Limited, Inc.
+ *  Copyright (C) 2014-2017, Lemote, Inc.
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/i8259.h>
+#include <asm/mipsregs.h>
+
+#include <irq.h>
+#include <loongson.h>
+#include "smp.h"
+
+static unsigned int irq_cpu[NR_IRQS] = {[0 ... NR_IRQS-1] = -1};
+static unsigned int ht_irq[] = {0, 1, 3, 4, 5, 6, 7, 8, 12, 14, 15};
+
+void rs780_irq_dispatch(void)
+{
+	unsigned int i, irq;
+	struct irq_data *irqd;
+	struct cpumask affinity;
+
+	irq = LOONGSON_HT1_INT_VECTOR(0);
+	LOONGSON_HT1_INT_VECTOR(0) = irq; /* Acknowledge the IRQs */
+
+	for (i = 0; i < ARRAY_SIZE(ht_irq); i++) {
+		if (!(irq & (0x1 << ht_irq[i])))
+			continue;
+
+		/* handled by local core */
+		if (loongson_ipi_irq2pos[ht_irq[i]] == -1) {
+			do_IRQ(ht_irq[i]);
+			continue;
+		}
+
+		irqd = irq_get_irq_data(ht_irq[i]);
+		cpumask_and(&affinity, irqd->common->affinity, cpu_active_mask);
+		if (cpumask_empty(&affinity)) {
+			do_IRQ(ht_irq[i]);
+			continue;
+		}
+
+		irq_cpu[ht_irq[i]] = cpumask_next(irq_cpu[ht_irq[i]], &affinity);
+		if (irq_cpu[ht_irq[i]] >= nr_cpu_ids)
+			irq_cpu[ht_irq[i]] = cpumask_first(&affinity);
+
+		if (irq_cpu[ht_irq[i]] == 0) {
+			do_IRQ(ht_irq[i]);
+			continue;
+		}
+
+		/* balanced by other cores */
+		loongson3_send_irq_by_ipi(irq_cpu[ht_irq[i]], (0x1 << (loongson_ipi_irq2pos[ht_irq[i]])));
+	}
+}
+
+void rs780_init_irq(void)
+{
+	int i;
+	struct irq_chip *chip;
+
+	/* Route LPC int to cpu Core0 INT0 */
+	LOONGSON_INT_ROUTER_LPC = LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 0);
+	/* Route HT1 int0 ~ int3 to cpu Core0 INT1 */
+	for (i = 0; i < 4; i++)
+		LOONGSON_INT_ROUTER_HT1(i) = LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 1);
+	/* Enable HT1 interrupts */
+	LOONGSON_HT1_INTN_EN(0) = 0xffffffff;
+	/* Enable router interrupt intenset */
+	LOONGSON_INT_ROUTER_INTENSET =
+		LOONGSON_INT_ROUTER_INTEN | (0xffff << 16) | 0x1 << 10;
+
+	chip = irq_get_chip(I8259A_IRQ_BASE);
+	chip->irq_set_affinity = plat_set_irq_affinity;
+
+	for (i = 0; i < NR_IRQS; i++)
+		loongson_ipi_irq2pos[i] = -1;
+	for (i = 0; i < NR_DIRQS; i++)
+		loongson_ipi_pos2irq[i] = -1;
+	create_ipi_dirq(3);
+	create_ipi_dirq(4);
+	create_ipi_dirq(5);
+	create_ipi_dirq(6);
+	create_ipi_dirq(14);
+	create_ipi_dirq(15);
+}
diff --git a/arch/mips/loongson64/loongson-3/rs780-platform.c b/arch/mips/loongson64/loongson-3/rs780-platform.c
new file mode 100644
index 000000000..61220ef82
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/rs780-platform.c
@@ -0,0 +1,58 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Copyright (C) 2013, Loongson Technology Corporation Limited, Inc.
+ *  Copyright (C) 2014-2017, Lemote, Inc.
+ */
+#include <linux/init.h>
+#include <asm/io.h>
+#include <pci.h>
+#include <boot_param.h>
+#include <loongson-pch.h>
+
+static void rs780_early_config(void)
+{
+	pci_request_acs();
+}
+
+static struct resource pci_mem_resource = {
+	.name	= "pci memory space",
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource pci_io_resource = {
+	.name	= "pci io space",
+	.flags	= IORESOURCE_IO,
+};
+
+static struct pci_controller rs780_pci_controller = {
+	.pci_ops	= &rs780_pci_ops,
+	.io_resource	= &pci_io_resource,
+	.mem_resource	= &pci_mem_resource,
+	.mem_offset	= 0x00000000UL,
+	.io_offset	= 0x00000000UL,
+};
+
+static void __init rs780_arch_initcall(void)
+{
+	pci_mem_resource.start = loongson_sysconf.pci_mem_start_addr;
+	pci_mem_resource.end   = loongson_sysconf.pci_mem_end_addr;
+	pci_io_resource.start  = LOONGSON_PCI_IO_START;
+	pci_io_resource.end    = 0x3ffff;
+	ioport_resource.end    = 0xfffff;
+	rs780_pci_controller.io_map_base = mips_io_port_base;
+	register_pci_controller(&rs780_pci_controller);
+}
+
+static void __init rs780_device_initcall(void)
+{
+}
+
+struct platform_controller_hub rs780_pch = {
+	.type			= RS780E,
+	.pcidev_max_funcs 	= 7,
+	.early_config		= rs780_early_config,
+	.init_irq		= rs780_init_irq,
+	.irq_dispatch		= rs780_irq_dispatch,
+	.pch_arch_initcall	= rs780_arch_initcall,
+	.pch_device_initcall	= rs780_device_initcall,
+};
diff --git a/arch/mips/loongson64/loongson-3/sleep.S b/arch/mips/loongson64/loongson-3/sleep.S
index bdee2da4e..62e7566e8 100644
--- a/arch/mips/loongson64/loongson-3/sleep.S
+++ b/arch/mips/loongson64/loongson-3/sleep.S
@@ -123,8 +123,11 @@ flushL2_node:
 	addiu  a0, a0, -1
 	bnez   a0, flushL2_all
 
-	ld  v0, loongson_suspend_addr /* Call BIOS's STR sleep routine */
-	jr  v0
+	/* Pass RA and SP to BIOS, for machines without CMOS RAM */
+	daddi	a1, sp, 0
+	dla	a0, wakeup_start
+	ld      v0, loongson_suspend_addr /* Call BIOS's STR sleep routine */
+	jr      v0
 	nop
 END(loongson_suspend_enter)
 
diff --git a/arch/mips/loongson64/loongson-3/smp.c b/arch/mips/loongson64/loongson-3/smp.c
index 92409dba8..941f608e6 100644
--- a/arch/mips/loongson64/loongson-3/smp.c
+++ b/arch/mips/loongson64/loongson-3/smp.c
@@ -18,6 +18,7 @@
 #include <asm/tlbflush.h>
 #include <asm/cacheflush.h>
 #include <loongson.h>
+#include <loongson-pch.h>
 #include <loongson_regs.h>
 #include <workarounds.h>
 
@@ -309,8 +310,6 @@ loongson3_send_ipi_mask(const struct cpumask *mask, unsigned int action)
 		ipi_write_action(cpu_logical_map(i), (u32)action);
 }
 
-#define IPI_IRQ_OFFSET 6
-
 void loongson3_send_irq_by_ipi(int cpu, int irqs)
 {
 	ipi_write_action(cpu_logical_map(cpu), irqs << IPI_IRQ_OFFSET);
@@ -344,8 +343,9 @@ void loongson3_ipi_interrupt(struct pt_regs *regs)
 
 	if (irqs) {
 		int irq;
+
 		while ((irq = ffs(irqs))) {
-			do_IRQ(irq-1);
+			do_IRQ(loongson_ipi_pos2irq[irq-1]);
 			irqs &= ~(1<<(irq-1));
 		}
 	}
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index d6de4cb2e..6c677c374 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -35,7 +35,7 @@ obj-$(CONFIG_LASAT)		+= pci-lasat.o
 obj-$(CONFIG_MIPS_COBALT)	+= fixup-cobalt.o
 obj-$(CONFIG_LEMOTE_FULOONG2E)	+= fixup-fuloong2e.o ops-loongson2.o
 obj-$(CONFIG_LEMOTE_MACH2F)	+= fixup-lemote2f.o ops-loongson2.o
-obj-$(CONFIG_LOONGSON_MACH3X)	+= fixup-loongson3.o ops-loongson3.o
+obj-$(CONFIG_LOONGSON_MACH3X)	+= fixup-loongson3.o ops-loongson3-ls2h.o ops-loongson3-rs780.o
 obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o pci-malta.o
 obj-$(CONFIG_PMC_MSP7120_GW)	+= fixup-pmcmsp.o ops-pmcmsp.o
 obj-$(CONFIG_PMC_MSP7120_EVAL)	+= fixup-pmcmsp.o ops-pmcmsp.o
diff --git a/arch/mips/pci/fixup-loongson3.c b/arch/mips/pci/fixup-loongson3.c
index 8a741c2c6..14d8317bc 100644
--- a/arch/mips/pci/fixup-loongson3.c
+++ b/arch/mips/pci/fixup-loongson3.c
@@ -24,7 +24,9 @@
  */
 
 #include <linux/pci.h>
+#include <irq.h>
 #include <boot_param.h>
+#include <workarounds.h>
 
 static void print_fixup_info(const struct pci_dev *pdev)
 {
@@ -61,11 +63,15 @@ static void pci_fixup_radeon(struct pci_dev *pdev)
 		 PCI_ROM_RESOURCE, res);
 }
 
-DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ATI, PCI_ANY_ID,
+DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_ATI, 0x9615,
 				PCI_CLASS_DISPLAY_VGA, 8, pci_fixup_radeon);
 
 /* Do platform specific device initialization at pci_enable_device() time */
 int pcibios_plat_dev_init(struct pci_dev *dev)
 {
+	dev->dev.dma_attrs = 0;
+	if (loongson_sysconf.workarounds & WORKAROUND_PCIE_DMA)
+		dev->dev.dma_attrs = DMA_ATTR_FORCE_SWIOTLB;
+
 	return 0;
 }
diff --git a/arch/mips/pci/ops-loongson3-ls2h.c b/arch/mips/pci/ops-loongson3-ls2h.c
new file mode 100644
index 000000000..e84d0c5e7
--- /dev/null
+++ b/arch/mips/pci/ops-loongson3-ls2h.c
@@ -0,0 +1,205 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2004 ICT CAS
+ * Author: Xiaoyu Li <lixy@ict.ac.cn>, ICT CAS
+ * Copyright (C) 2012-2017 Lemote, Inc.
+ * Author: Huacai Chen <chenhc@lemote.com>, Lemote, Inc.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+
+#include <loongson-pch.h>
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+static int is_link_up(u8 port)
+{
+	u32 *reg, data;
+
+	reg = (u32 *)(LS2H_PCIE_PORT_REG_BASE(port) | LS2H_PCIE_PORT_REG_STAT1);
+	data = readl(reg);
+
+	return data & LS2H_PCIE_REG_STAT1_BIT_LINKUP;
+}
+
+static int ls2h_pci_config_access(unsigned char access_type,
+				  struct pci_bus *bus, unsigned int devfn,
+				  int where, u32 *data, unsigned char portnum)
+{
+	u_int32_t cfg_addr;
+	u_int64_t addr, addr_i;
+	int type, busnum = bus->number;
+	int device = devfn >> 3;
+	int function = devfn & 0x7;
+	int reg = where & ~3;
+
+	if (portnum > LS2H_PCIE_MAX_PORTNUM)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (!bus->parent) {
+		/* in-chip virtual-bus has no parent,
+		 * so access is routed to PORT_HEAD
+		 */
+		if (device > 0 || function > 0) {
+			*data = -1;
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		} else {
+			addr = LS2H_PCIE_PORT_HEAD_BASE(portnum) | reg;
+			if (reg == PCI_BASE_ADDRESS_0)
+				/* the default value of PCI_BASE_ADDRESS_0 of
+				 * PORT_HEAD is wrong, use PCI_BASE_ADDESS_1 instead
+				 */
+				addr += 4;
+		}
+	} else {
+		if (busnum > 255 || device > 31 || function > 1
+				|| !is_link_up(portnum)) {
+			*data = -1;
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		}
+
+		if (!bus->parent->parent) {
+			/* the bus is child of virtual-bus(pcie slot),
+			 * so use Type 0 access for device on it
+			 */
+			if (device > 0) {
+				*data = -1;
+				return PCIBIOS_DEVICE_NOT_FOUND;
+			}
+			type = 0;
+		} else {
+			/* the bus is emitted from offboard-bridge,
+			 * so use Type 1 access for device on it
+			 */
+			type = 1;
+		}
+
+		/* write busnum/devnum/funcnum/type into PCIE_REG_BASE + 0x24 */
+		cfg_addr = (busnum << 16) | (device << 11) | (function << 8) | type;
+		addr_i = LS2H_PCIE_PORT_REG_BASE(portnum) | LS2H_PCIE_PORT_REG_CFGADDR;
+		writel(cfg_addr, (void *)addr_i);
+
+		/* access mapping memory instead of direct configuration access */
+		addr = LS2H_PCIE_DEV_HEAD_BASE(portnum) | reg;
+	}
+
+	if (access_type == PCI_ACCESS_WRITE)
+		writel(*data, (void *)addr);
+	else
+		*data = readl((void *)addr);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ls2h_pcibios_read_port(struct pci_bus *bus, unsigned int devfn,
+				       int where, int size, u32 * val, u8 port)
+{
+	u32 data = 0;
+
+	if (ls2h_pci_config_access(PCI_ACCESS_READ, bus, devfn, where,
+				&data, port))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ls2h_pcibios_write_port(struct pci_bus *bus, unsigned int devfn,
+					int where, int size, u32 val, u8 port)
+{
+	u32 data = 0;
+
+	if (size == 4)
+		data = val;
+	else {
+		if (ls2h_pci_config_access(PCI_ACCESS_READ, bus, devfn, where,
+					&data, port))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+
+		if (size == 1)
+			data = (data & ~(0xff << ((where & 3) << 3))) |
+			    (val << ((where & 3) << 3));
+		else if (size == 2)
+			data = (data & ~(0xffff << ((where & 3) << 3))) |
+			    (val << ((where & 3) << 3));
+	}
+
+	if (ls2h_pci_config_access(PCI_ACCESS_WRITE, bus, devfn, where,
+				&data, port))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ls2h_pci_pcibios_read_port0(struct pci_bus *bus, unsigned int devfn,
+				       int where, int size, u32 *val)
+{
+	return ls2h_pcibios_read_port(bus, devfn, where, size, val, 0);
+}
+
+static int ls2h_pci_pcibios_write_port0(struct pci_bus *bus, unsigned int devfn,
+					int where, int size, u32 val)
+{
+	return ls2h_pcibios_write_port(bus, devfn, where, size, val, 0);
+}
+
+static int ls2h_pci_pcibios_read_port1(struct pci_bus *bus, unsigned int devfn,
+				       int where, int size, u32 *val)
+{
+	return ls2h_pcibios_read_port(bus, devfn, where, size, val, 1);
+}
+
+static int ls2h_pci_pcibios_write_port1(struct pci_bus *bus, unsigned int devfn,
+					int where, int size, u32 val)
+{
+	return ls2h_pcibios_write_port(bus, devfn, where, size, val, 1);
+}
+static int ls2h_pci_pcibios_read_port2(struct pci_bus *bus, unsigned int devfn,
+				       int where, int size, u32 *val)
+{
+	return ls2h_pcibios_read_port(bus, devfn, where, size, val, 2);
+}
+
+static int ls2h_pci_pcibios_write_port2(struct pci_bus *bus, unsigned int devfn,
+					int where, int size, u32 val)
+{
+	return ls2h_pcibios_write_port(bus, devfn, where, size, val, 2);
+}
+static int ls2h_pci_pcibios_read_port3(struct pci_bus *bus, unsigned int devfn,
+				       int where, int size, u32 *val)
+{
+	return ls2h_pcibios_read_port(bus, devfn, where, size, val, 3);
+}
+
+static int ls2h_pci_pcibios_write_port3(struct pci_bus *bus, unsigned int devfn,
+					int where, int size, u32 val)
+{
+	return ls2h_pcibios_write_port(bus, devfn, where, size, val, 3);
+}
+
+struct pci_ops ls2h_pci_ops[4] = {
+	{
+		.read	= ls2h_pci_pcibios_read_port0,
+		.write	= ls2h_pci_pcibios_write_port0
+	},
+	{
+		.read	= ls2h_pci_pcibios_read_port1,
+		.write	= ls2h_pci_pcibios_write_port1
+	},
+	{
+		.read	= ls2h_pci_pcibios_read_port2,
+		.write	= ls2h_pci_pcibios_write_port2
+	},
+	{
+		.read	= ls2h_pci_pcibios_read_port3,
+		.write	= ls2h_pci_pcibios_write_port3
+	}
+};
diff --git a/arch/mips/pci/ops-loongson3.c b/arch/mips/pci/ops-loongson3-rs780.c
similarity index 80%
rename from arch/mips/pci/ops-loongson3.c
rename to arch/mips/pci/ops-loongson3-rs780.c
index 2f6ad36bd..c68f9c43a 100644
--- a/arch/mips/pci/ops-loongson3.c
+++ b/arch/mips/pci/ops-loongson3-rs780.c
@@ -1,4 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) Lemote, Inc.
+ * Author: Huacai Chen <chenhc@lemote.com>
+ */
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
@@ -13,13 +17,13 @@
 #define HT1LO_PCICFG_BASE      0x1a000000
 #define HT1LO_PCICFG_BASE_TP1  0x1b000000
 
-static int loongson3_pci_config_access(unsigned char access_type,
+static int rs780_pci_config_access(unsigned char access_type,
 		struct pci_bus *bus, unsigned int devfn,
 		int where, u32 *data)
 {
 	unsigned char busnum = bus->number;
-	int function = PCI_FUNC(devfn);
 	int device = PCI_SLOT(devfn);
+	int function = PCI_FUNC(devfn);
 	int reg = where & ~3;
 	void *addrp;
 	u64 addr;
@@ -62,11 +66,11 @@ static int loongson3_pci_config_access(unsigned char access_type,
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int loongson3_pci_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+static int rs780_pci_pcibios_read(struct pci_bus *bus, unsigned int devfn,
 				 int where, int size, u32 *val)
 {
 	u32 data = 0;
-	int ret = loongson3_pci_config_access(PCI_ACCESS_READ,
+	int ret = rs780_pci_config_access(PCI_ACCESS_READ,
 			bus, devfn, where, &data);
 
 	if (ret != PCIBIOS_SUCCESSFUL)
@@ -82,7 +86,7 @@ static int loongson3_pci_pcibios_read(struct pci_bus *bus, unsigned int devfn,
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int loongson3_pci_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+static int rs780_pci_pcibios_write(struct pci_bus *bus, unsigned int devfn,
 				  int where, int size, u32 val)
 {
 	u32 data = 0;
@@ -91,7 +95,7 @@ static int loongson3_pci_pcibios_write(struct pci_bus *bus, unsigned int devfn,
 	if (size == 4)
 		data = val;
 	else {
-		ret = loongson3_pci_config_access(PCI_ACCESS_READ,
+		ret = rs780_pci_config_access(PCI_ACCESS_READ,
 				bus, devfn, where, &data);
 		if (ret != PCIBIOS_SUCCESSFUL)
 			return ret;
@@ -104,13 +108,13 @@ static int loongson3_pci_pcibios_write(struct pci_bus *bus, unsigned int devfn,
 			    (val << ((where & 3) << 3));
 	}
 
-	ret = loongson3_pci_config_access(PCI_ACCESS_WRITE,
+	ret = rs780_pci_config_access(PCI_ACCESS_WRITE,
 			bus, devfn, where, &data);
 
 	return ret;
 }
 
-struct pci_ops loongson_pci_ops = {
-	.read = loongson3_pci_pcibios_read,
-	.write = loongson3_pci_pcibios_write
+struct pci_ops rs780_pci_ops = {
+	.read = rs780_pci_pcibios_read,
+	.write = rs780_pci_pcibios_write
 };
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index 30b9393ae..b9010a6c5 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -408,13 +408,6 @@ static void stmmac_ethtool_setmsglevel(struct net_device *dev, u32 level)
 
 }
 
-static int stmmac_check_if_running(struct net_device *dev)
-{
-	if (!netif_running(dev))
-		return -EBUSY;
-	return 0;
-}
-
 static int stmmac_ethtool_get_regs_len(struct net_device *dev)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
@@ -922,7 +915,6 @@ static int stmmac_set_tunable(struct net_device *dev,
 }
 
 static const struct ethtool_ops stmmac_ethtool_ops = {
-	.begin = stmmac_check_if_running,
 	.get_drvinfo = stmmac_ethtool_getdrvinfo,
 	.get_msglevel = stmmac_ethtool_getmsglevel,
 	.set_msglevel = stmmac_ethtool_setmsglevel,
diff --git a/drivers/platform/mips/lemote3a-laptop.c b/drivers/platform/mips/lemote3a-laptop.c
index f69a0940d..a571d50a1 100644
--- a/drivers/platform/mips/lemote3a-laptop.c
+++ b/drivers/platform/mips/lemote3a-laptop.c
@@ -29,7 +29,9 @@
 #include <linux/leds.h>
 #include <asm/bootinfo.h>
 
+#include <boot_param.h>
 #include <ec_wpce775l.h>
+#include <loongson-pch.h>
 
 #define KEY_TOUCHPAD_SW	KEY_F21
 #define KEY_MODEM	KEY_F24
@@ -75,7 +77,6 @@ enum /* bat_reg_flag */
 
 /* SCI device */
 #define EC_SCI_DEV		"sci"	/* < 10 bytes. */
-#define SCI_IRQ_NUM		0x07
 #define GPIO_SIZE		256
 
 const char *version = EC_VERSION;
@@ -588,7 +589,8 @@ static int lemote3a_laptop_suspend(struct platform_device * pdev, pm_message_t s
 	struct pci_dev *dev;
 
 	dev = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
-	pci_disable_device(dev);
+	if (dev)
+		pci_disable_device(dev);
 
 	return 0;
 }
@@ -599,7 +601,8 @@ static int lemote3a_laptop_resume(struct platform_device * pdev)
 	struct pci_dev *dev;
 
 	dev = pci_get_device(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);
-	pci_enable_device(dev);
+	if (dev)
+		pci_enable_device(dev);
 
 	/* Process LID event */
 	lemote3a_sci_event_handler(SCI_EVENT_NUM_LID);
@@ -1039,18 +1042,20 @@ static int sci_pci_init(void)
 	}
 
 	/* Fill sci device */
-	lemote3a_sci_device->irq = SCI_IRQ_NUM;
+	lemote3a_sci_device->irq = loongson_sysconf.ec_sci_irq;
 	lemote3a_sci_device->irq_data = 0x00;
 	lemote3a_sci_device->number = 0x00;
 	lemote3a_sci_device->parameter = 0x00;
 	strcpy(lemote3a_sci_device->name, EC_SCI_DEV);
 
 	/* Enable pci device and get the GPIO resources. */
-	ret = pci_enable_device(pdev);
-	if (ret) {
-		printk(KERN_ERR "Lemote Laptop Platform Driver : Enable pci device failed!\n");
-		ret = -ENODEV;
-		goto out_pdev;
+	if (pdev) {
+		ret = pci_enable_device(pdev);
+		if (ret) {
+			printk(KERN_ERR "Lemote Laptop Platform Driver : Enable pci device failed!\n");
+			ret = -ENODEV;
+			goto out_pdev;
+		}
 	}
 
 	/* Clear sci status: GPM9Status field in bit14 of
@@ -1071,7 +1076,8 @@ static int sci_pci_init(void)
 	goto out;
 
 out_irq:
-	pci_disable_device(pdev);
+	if (pdev)
+		pci_disable_device(pdev);
 out_pdev:
 	kfree(lemote3a_sci_device);
 out:
diff --git a/drivers/usb/dwc2/params.c b/drivers/usb/dwc2/params.c
index 6d3812678..1129791b6 100644
--- a/drivers/usb/dwc2/params.c
+++ b/drivers/usb/dwc2/params.c
@@ -163,6 +163,14 @@ static void dwc2_set_stm32f7_hsotg_params(struct dwc2_hsotg *hsotg)
 	p->host_perio_tx_fifo_size = 256;
 }
 
+static void dwc2_set_loongson_params(struct dwc2_hsotg *hsotg)
+{
+	struct dwc2_core_params *p = &hsotg->params;
+
+	p->phy_utmi_width = 8;
+	p->power_down = DWC2_POWER_DOWN_PARAM_HIBERNATION;
+}
+
 const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "brcm,bcm2835-usb", .data = dwc2_set_bcm_params },
 	{ .compatible = "hisilicon,hi6220-usb", .data = dwc2_set_his_params  },
@@ -186,6 +194,7 @@ const struct of_device_id dwc2_of_match_table[] = {
 	{ .compatible = "st,stm32f4x9-hsotg" },
 	{ .compatible = "st,stm32f7-hsotg",
 	  .data = dwc2_set_stm32f7_hsotg_params },
+	{ .compatible = "loongson,dwc2", .data = dwc2_set_loongson_params },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dwc2_of_match_table);
diff --git a/include/linux/device.h b/include/linux/device.h
index c7be3a807..b2e1881cc 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -1317,6 +1317,7 @@ struct device {
     defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
 	bool			dma_coherent:1;
 #endif
+	unsigned long dma_attrs;
 };
 
 static inline struct device *kobj_to_dev(struct kobject *kobj)
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index 87cbae4b0..d3eddf33c 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -70,6 +70,12 @@
  */
 #define DMA_ATTR_PRIVILEGED		(1UL << 9)
 
+/*
+ * DMA_ATTR_FORCE_SWIOTLB: Forces device to use swiotlb because of some
+ * DMA alignment requirement.
+ */
+#define DMA_ATTR_FORCE_SWIOTLB		(1UL << 10)
+
 /*
  * A dma_addr_t can hold any valid DMA or bus address for the platform.
  * It can be given to a device to use as a DMA source or target.  A CPU cannot
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index 4c21cdc15..05544d3d5 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -325,9 +325,10 @@ EXPORT_SYMBOL(dma_direct_unmap_sg);
 #endif
 
 static inline bool dma_direct_possible(struct device *dev, dma_addr_t dma_addr,
-		size_t size)
+		size_t size, unsigned long attrs)
 {
-	return swiotlb_force != SWIOTLB_FORCE &&
+	int dev_swiotlb_force = attrs & DMA_ATTR_FORCE_SWIOTLB;
+	return swiotlb_force != SWIOTLB_FORCE && !dev_swiotlb_force &&
 		dma_capable(dev, dma_addr, size);
 }
 
@@ -338,7 +339,7 @@ dma_addr_t dma_direct_map_page(struct device *dev, struct page *page,
 	phys_addr_t phys = page_to_phys(page) + offset;
 	dma_addr_t dma_addr = phys_to_dma(dev, phys);
 
-	if (unlikely(!dma_direct_possible(dev, dma_addr, size)) &&
+	if (unlikely(!dma_direct_possible(dev, dma_addr, size, attrs)) &&
 	    !swiotlb_map(dev, &phys, &dma_addr, size, dir, attrs)) {
 		report_addr(dev, dma_addr, size);
 		return DMA_MAPPING_ERROR;
@@ -377,6 +378,9 @@ dma_addr_t dma_direct_map_resource(struct device *dev, phys_addr_t paddr,
 {
 	dma_addr_t dma_addr = paddr;
 
+	if (attrs & DMA_ATTR_FORCE_SWIOTLB)
+		return DMA_MAPPING_ERROR;
+
 	if (unlikely(!dma_capable(dev, dma_addr, size))) {
 		report_addr(dev, dma_addr, size);
 		return DMA_MAPPING_ERROR;
-- 
2.39.1

