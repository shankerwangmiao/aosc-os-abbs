From 6944f2bfb21c817786cd04ceb7e1d44e56e083d0 Mon Sep 17 00:00:00 2001
From: Binbin Zhou <zhoubb@lemote.com>
Date: Fri, 24 Nov 2017 11:36:07 +0800
Subject: [PATCH 099/136] Loongson: Add basic support for LS7A bridge

Signed-off-by: Binbin Zhou <zhoubb@lemote.com>
---
 arch/mips/boot/dts/loongson/Makefile          |   2 +-
 .../mips/boot/dts/loongson/loongson3_ls7a.dts | 173 ++++++++++++++
 arch/mips/include/asm/hpet.h                  |   3 +
 .../include/asm/mach-loongson64/boot_param.h  |   1 +
 arch/mips/include/asm/mach-loongson64/irq.h   |  51 +++++
 .../asm/mach-loongson64/loongson-pch.h        |  53 ++++-
 arch/mips/loongson64/Kconfig                  |   2 +-
 arch/mips/loongson64/common/env.c             |   7 +-
 arch/mips/loongson64/common/rtc.c             |   1 +
 arch/mips/loongson64/loongson-3/Makefile      |   5 +-
 arch/mips/loongson64/loongson-3/acpi_init.c   |   7 +
 arch/mips/loongson64/loongson-3/dma.c         |  22 ++
 arch/mips/loongson64/loongson-3/hpet.c        |   6 +
 arch/mips/loongson64/loongson-3/ls7a-gpio.c   | 118 ++++++++++
 arch/mips/loongson64/loongson-3/ls7a-irq.c    | 213 ++++++++++++++++++
 .../loongson64/loongson-3/ls7a-platform.c     |  76 +++++++
 arch/mips/pci/Makefile                        |   2 +-
 arch/mips/pci/ops-loongson3-ls7a.c            | 128 +++++++++++
 drivers/ata/ahci.c                            |   6 +
 drivers/platform/mips/emc1412.c               |  18 +-
 include/linux/pci_ids.h                       |  12 +
 21 files changed, 895 insertions(+), 11 deletions(-)
 create mode 100644 arch/mips/boot/dts/loongson/loongson3_ls7a.dts
 create mode 100644 arch/mips/loongson64/loongson-3/ls7a-gpio.c
 create mode 100644 arch/mips/loongson64/loongson-3/ls7a-irq.c
 create mode 100644 arch/mips/loongson64/loongson-3/ls7a-platform.c
 create mode 100644 arch/mips/pci/ops-loongson3-ls7a.c

diff --git a/arch/mips/boot/dts/loongson/Makefile b/arch/mips/boot/dts/loongson/Makefile
index 0f1c4dcb0..19775d733 100644
--- a/arch/mips/boot/dts/loongson/Makefile
+++ b/arch/mips/boot/dts/loongson/Makefile
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0
-dtb-$(CONFIG_CPU_LOONGSON3)	+= loongson3_ls2h.dtb loongson3_rs780.dtb
+dtb-$(CONFIG_CPU_LOONGSON3)	+= loongson3_ls2h.dtb loongson3_ls7a.dtb loongson3_rs780.dtb
 
 obj-y				+= $(patsubst %.dtb, %.dtb.o, $(dtb-y))
diff --git a/arch/mips/boot/dts/loongson/loongson3_ls7a.dts b/arch/mips/boot/dts/loongson/loongson3_ls7a.dts
new file mode 100644
index 000000000..b2ccb16e8
--- /dev/null
+++ b/arch/mips/boot/dts/loongson/loongson3_ls7a.dts
@@ -0,0 +1,173 @@
+/dts-v1/;
+#include "loongson3.dtsi"
+/ {
+	model = "loongson,generic";
+	compatible = "loongson,loongson3";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	memory {
+		name = "memory";
+		device_type = "memory";
+	};
+
+	cpuic: interrupt-controller {
+		compatible = "mti,cpu-interrupt-controller";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+	};
+
+	platic: interrupt-controller@1bd00040 {
+		compatible = "loongson,ls7a-interrupt-controller";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		interrupts = <3>;
+		interrupt-parent = <&cpuic>;
+	};
+
+	aliases {
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+		i2c6 = &i2c6;
+		i2c7 = &i2c7;
+	};
+
+	platform {
+		compatible = "loongson,nbus", "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <1>;
+		ranges = <0x000 0x00000000 0x000 0x00000000 0x20000000
+			  0x000 0x40000000 0x000 0x40000000 0x40000000
+			  0xe00 0x00000000 0xe00 0x00000000 0x80000000>;
+
+		uart0: serial@10080000 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x10080000 0x100>;
+			clock-frequency = <50000000>;
+			interrupts = <72>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		uart1: serial@10080100 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x10080100 0x100>;
+			clock-frequency = <50000000>;
+			interrupts = <72>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		uart2: serial@10080200 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x10080200 0x100>;
+			clock-frequency = <50000000>;
+			interrupts = <72>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		uart3: serial@10080300 {
+			device_type = "serial";
+			compatible = "ns16550a";
+			reg = <0 0x10080300 0x100>;
+			clock-frequency = <50000000>;
+			interrupts = <72>;
+			interrupt-parent = <&platic>;
+			no-loopback-test;
+		};
+
+		i2c0: i2c@10090000 {
+			compatible = "loongson,ls7a-i2c";
+			reg = <0 0x10090000 0x8>;
+			interrupts = <73>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c1: i2c@10090100 {
+			compatible = "loongson,ls7a-i2c";
+			reg = <0 0x10090100 0x8>;
+			interrupts = <73>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c2: i2c@10090200 {
+			compatible = "loongson,ls7a-i2c";
+			reg = <0 0x10090200 0x8>;
+			interrupts = <73>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c3: i2c@10090300 {
+			compatible = "loongson,ls7a-i2c";
+			reg = <0 0x10090300 0x8>;
+			interrupts = <73>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c4: i2c@10090400 {
+			compatible = "loongson,ls7a-i2c";
+			reg = <0 0x10090400 0x8>;
+			interrupts = <73>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c5: i2c@10090500 {
+			compatible = "loongson,ls7a-i2c";
+			reg = <0 0x10090500 0x8>;
+			interrupts = <73>;
+			interrupt-parent = <&platic>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c6: i2c-gpio@0 {
+			compatible = "i2c-gpio";
+			gpios = <&gpio 57 0 /* sda */
+				 &gpio 58 0 /* scl */
+				>;
+			i2c-gpio,delay-us = <100>;
+		};
+
+		i2c7: i2c-gpio@1 {
+			compatible = "i2c-gpio";
+			gpios = <&gpio 59 0 /* sda */
+				 &gpio 60 0 /* scl */
+				>;
+			i2c-gpio,delay-us = <100>;
+		};
+
+		rtc0: rtc@100d0100 {
+			compatible = "loongson,ls7a-rtc";
+			reg = <0 0x100d0100 0x100>;
+			interrupts = <116>;
+			interrupt-parent = <&platic>;
+		};
+
+		gpio: gpio@100e0000 {
+			compatible = "loongson,ls7a-gpio";
+			reg = <0 0x100e0000 0xc00>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupts = <124>;
+			interrupt-parent = <&platic>;
+		};
+	};
+};
diff --git a/arch/mips/include/asm/hpet.h b/arch/mips/include/asm/hpet.h
index ab9c69d2e..10d007b6d 100644
--- a/arch/mips/include/asm/hpet.h
+++ b/arch/mips/include/asm/hpet.h
@@ -67,6 +67,9 @@
 #define LS2H_HPET_BASE		0x900000001bec0000
 #define LS2H_HPET_FREQ		125000000
 #define LS2H_HPET_T0_IRQ	LS2H_PCH_HPET_IRQ
+#define LS7A_HPET_BASE		0x90000e0010001000
+#define LS7A_HPET_FREQ		50000000
+#define LS7A_HPET_T0_IRQ	LS7A_PCH_HPET_IRQ
 #define RS780_HPET_BASE		0x90000e0000020000
 #define RS780_HPET_FREQ		14318780
 #define RS780_HPET_T0_IRQ	RS780_PCH_HPET_IRQ
diff --git a/arch/mips/include/asm/mach-loongson64/boot_param.h b/arch/mips/include/asm/mach-loongson64/boot_param.h
index 6d0cf7d74..b404e137a 100644
--- a/arch/mips/include/asm/mach-loongson64/boot_param.h
+++ b/arch/mips/include/asm/mach-loongson64/boot_param.h
@@ -223,6 +223,7 @@ struct loongson_system_configuration {
 
 extern void *loongson_fdt_blob;
 extern u32 __dtb_loongson3_ls2h_begin[];
+extern u32 __dtb_loongson3_ls7a_begin[];
 extern u32 __dtb_loongson3_rs780_begin[];
 extern struct efi_memory_map_loongson *loongson_memmap;
 extern struct loongson_system_configuration loongson_sysconf;
diff --git a/arch/mips/include/asm/mach-loongson64/irq.h b/arch/mips/include/asm/mach-loongson64/irq.h
index 252473f3a..6d9100ce7 100644
--- a/arch/mips/include/asm/mach-loongson64/irq.h
+++ b/arch/mips/include/asm/mach-loongson64/irq.h
@@ -108,6 +108,57 @@
 #define LS2H_PCH_GPIO15_IRQ		(LS2H_PCH_IRQ_BASE + 79)
 #define LS2H_PCH_LAST_IRQ		(LS2H_PCH_IRQ_BASE + 160)
 
+#define LS7A_PCH_IRQ_BASE		64
+#define LS7A_PCH_UART0_IRQ		(LS7A_PCH_IRQ_BASE + 8)
+#define LS7A_PCH_I2C0_IRQ		(LS7A_PCH_IRQ_BASE + 9)
+#define LS7A_PCH_GMAC0_SBD_IRQ		(LS7A_PCH_IRQ_BASE + 12)
+#define LS7A_PCH_GMAC0_PMT_IRQ		(LS7A_PCH_IRQ_BASE + 13)
+#define LS7A_PCH_GMAC1_SBD_IRQ		(LS7A_PCH_IRQ_BASE + 14)
+#define LS7A_PCH_GMAC1_PMT_IRQ		(LS7A_PCH_IRQ_BASE + 15)
+#define LS7A_PCH_SATA0_IRQ		(LS7A_PCH_IRQ_BASE + 16)
+#define LS7A_PCH_SATA1_IRQ		(LS7A_PCH_IRQ_BASE + 17)
+#define LS7A_PCH_SATA2_IRQ		(LS7A_PCH_IRQ_BASE + 18)
+#define LS7A_PCH_LPC_IRQ		(LS7A_PCH_IRQ_BASE + 19)
+#define LS7A_PCH_PWM0_IRQ		(LS7A_PCH_IRQ_BASE + 24)
+#define LS7A_PCH_PWM1_IRQ		(LS7A_PCH_IRQ_BASE + 25)
+#define LS7A_PCH_PWM2_IRQ		(LS7A_PCH_IRQ_BASE + 26)
+#define LS7A_PCH_PWM3_IRQ		(LS7A_PCH_IRQ_BASE + 27)
+#define LS7A_PCH_DC_IRQ			(LS7A_PCH_IRQ_BASE + 28)
+#define LS7A_PCH_GPU_IRQ		(LS7A_PCH_IRQ_BASE + 29)
+#define LS7A_PCH_PCIE_F0_PORT0_IRQ	(LS7A_PCH_IRQ_BASE + 32)
+#define LS7A_PCH_PCIE_F0_PORT1_IRQ	(LS7A_PCH_IRQ_BASE + 33)
+#define LS7A_PCH_PCIE_F0_PORT2_IRQ	(LS7A_PCH_IRQ_BASE + 34)
+#define LS7A_PCH_PCIE_F0_PORT3_IRQ	(LS7A_PCH_IRQ_BASE + 35)
+#define LS7A_PCH_PCIE_F1_PORT0_IRQ	(LS7A_PCH_IRQ_BASE + 36)
+#define LS7A_PCH_PCIE_F1_PORT1_IRQ	(LS7A_PCH_IRQ_BASE + 37)
+#define LS7A_PCH_PCIE_H_LO_IRQ		(LS7A_PCH_IRQ_BASE + 38)
+#define LS7A_PCH_PCIE_H_HI_IRQ		(LS7A_PCH_IRQ_BASE + 39)
+#define LS7A_PCH_PCIE_G0_LO_IRQ		(LS7A_PCH_IRQ_BASE + 40)
+#define LS7A_PCH_PCIE_G0_HI_IRQ		(LS7A_PCH_IRQ_BASE + 41)
+#define LS7A_PCH_PCIE_G1_LO_IRQ		(LS7A_PCH_IRQ_BASE + 42)
+#define LS7A_PCH_PCIE_G1_HI_IRQ		(LS7A_PCH_IRQ_BASE + 43)
+#define LS7A_PCH_TOY0_IRQ		(LS7A_PCH_IRQ_BASE + 44)
+#define LS7A_PCH_TOY1_IRQ		(LS7A_PCH_IRQ_BASE + 45)
+#define LS7A_PCH_TOY2_IRQ		(LS7A_PCH_IRQ_BASE + 46)
+#define LS7A_PCH_ACPI_IRQ		(LS7A_PCH_IRQ_BASE + 47)
+#define LS7A_PCH_EHCI0_IRQ		(LS7A_PCH_IRQ_BASE + 48)
+#define LS7A_PCH_OHCI0_IRQ		(LS7A_PCH_IRQ_BASE + 49)
+#define LS7A_PCH_EHCI1_IRQ		(LS7A_PCH_IRQ_BASE + 50)
+#define LS7A_PCH_OHCI1_IRQ		(LS7A_PCH_IRQ_BASE + 51)
+#define LS7A_PCH_RTC_INT0_IRQ		(LS7A_PCH_IRQ_BASE + 52)
+#define LS7A_PCH_RTC_INT1_IRQ		(LS7A_PCH_IRQ_BASE + 53)
+#define LS7A_PCH_RTC_INT2_IRQ		(LS7A_PCH_IRQ_BASE + 54)
+#define LS7A_PCH_HPET_IRQ		(LS7A_PCH_IRQ_BASE + 55)
+#define LS7A_PCH_AC97_DMA0_IRQ		(LS7A_PCH_IRQ_BASE + 56)
+#define LS7A_PCH_AC97_DMA1_IRQ		(LS7A_PCH_IRQ_BASE + 57)
+#define LS7A_PCH_AC97_HDA_IRQ		(LS7A_PCH_IRQ_BASE + 58)
+#define LS7A_PCH_GPIO_HI_IRQ		(LS7A_PCH_IRQ_BASE + 59)
+#define LS7A_PCH_GPIO_0_IRQ		(LS7A_PCH_IRQ_BASE + 60)
+#define LS7A_PCH_GPIO_1_IRQ		(LS7A_PCH_IRQ_BASE + 61)
+#define LS7A_PCH_GPIO_2_IRQ		(LS7A_PCH_IRQ_BASE + 62)
+#define LS7A_PCH_GPIO_3_IRQ		(LS7A_PCH_IRQ_BASE + 63)
+#define LS7A_PCH_LAST_IRQ		(LS7A_PCH_IRQ_BASE + 64)
+
 #define RS780_PCH_HPET_IRQ		0
 #define RS780_PCH_ACPI_IRQ		7
 
diff --git a/arch/mips/include/asm/mach-loongson64/loongson-pch.h b/arch/mips/include/asm/mach-loongson64/loongson-pch.h
index 1744774a0..5a4f62070 100644
--- a/arch/mips/include/asm/mach-loongson64/loongson-pch.h
+++ b/arch/mips/include/asm/mach-loongson64/loongson-pch.h
@@ -127,6 +127,50 @@
 #define LS2H_PCI_EXP_LNKCAP			0x7c
 #define LS2H_CLK_CTRL3_BIT_PEREF_EN(portnum)	(1 << (24 + portnum))
 
+/* ============== LS7A registers =============== */
+
+#define LS7A_PCH_REG_BASE		0x10000000
+/* CHIPCFG regs */
+#define LS7A_CHIPCFG_REG_BASE		(LS7A_PCH_REG_BASE + 0x00010000)
+/* MISC reg base */
+#define LS7A_MISC_REG_BASE		(LS7A_PCH_REG_BASE + 0x00080000)
+/* ACPI regs */
+#define LS7A_ACPI_REG_BASE		(LS7A_MISC_REG_BASE + 0x00050000)
+/* RTC regs */
+#define LS7A_RTC_REG_BASE		(LS7A_MISC_REG_BASE + 0x00050100)
+
+#define LS7A_INT_MASK_REG		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x020)
+#define LS7A_INT_EDGE_REG		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x060)
+#define LS7A_INT_CLEAR_REG		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x080)
+#define LS7A_INT_HTMSI_EN_REG		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x040)
+#define LS7A_INT_ROUTE_ENTRY_REG	(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x100)
+#define LS7A_INT_HTMSI_VEC_REG		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x200)
+#define LS7A_INT_STATUS_REG		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x3a0)
+#define LS7A_LPC_INT_CTL		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2000)
+#define LS7A_LPC_INT_ENA		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2004)
+#define LS7A_LPC_INT_STS		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2008)
+#define LS7A_LPC_INT_CLR		(void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x200c)
+
+#define LS7A_PMCON_SOC_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x000)
+#define LS7A_PMCON_RESUME_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x004)
+#define LS7A_PMCON_RTC_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x008)
+#define LS7A_PM1_EVT_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x00c)
+#define LS7A_PM1_ENA_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x010)
+#define LS7A_PM1_CNT_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x014)
+#define LS7A_PM1_TMR_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x018)
+#define LS7A_P_CNT_REG			(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x01c)
+#define LS7A_GPE0_STS_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x028)
+#define LS7A_GPE0_ENA_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x02c)
+#define LS7A_RST_CNT_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x030)
+#define LS7A_WD_SET_REG			(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x034)
+#define LS7A_WD_TIMER_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x038)
+#define LS7A_THSENS_CNT_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x04c)
+#define LS7A_GEN_RTC_1_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x050)
+#define LS7A_GEN_RTC_2_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x054)
+#define LS7A_DPM_CFG_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x400)
+#define LS7A_DPM_STS_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x404)
+#define LS7A_DPM_CNT_REG		(void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x408)
+
 /* ============== RS780/SBX00 registers =============== */
 
 #define SBX00_ACPI_IO_BASE 0x800
@@ -148,7 +192,8 @@
 
 enum b_type { /* BoardType(BridgeType) */
 	LS2H   = 1,
-	RS780E = 2
+	LS7A   = 2,
+	RS780E = 3
 };
 
 struct platform_controller_hub {
@@ -164,6 +209,7 @@ struct platform_controller_hub {
 };
 
 extern struct platform_controller_hub ls2h_pch;
+extern struct platform_controller_hub ls7a_pch;
 extern struct platform_controller_hub rs780_pch;
 extern struct platform_controller_hub *loongson_pch;
 
@@ -172,6 +218,11 @@ extern void ls2h_init_irq(void);
 extern void ls2h_irq_dispatch(void);
 extern int ls2h_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
 
+extern struct pci_ops ls7a_pci_ops;
+extern void ls7a_init_irq(void);
+extern void ls7a_irq_dispatch(void);
+extern int ls7a_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
+
 extern struct pci_ops rs780_pci_ops;
 extern void rs780_init_irq(void);
 extern void rs780_irq_dispatch(void);
diff --git a/arch/mips/loongson64/Kconfig b/arch/mips/loongson64/Kconfig
index dcdc14128..5ce3b5068 100644
--- a/arch/mips/loongson64/Kconfig
+++ b/arch/mips/loongson64/Kconfig
@@ -120,7 +120,7 @@ config LOONGSON_HPET
 	depends on LOONGSON_MACH3X
 	select MIPS_EXTERNAL_TIMER
 	help
-	  This option enables the hpet timer of LS2H or AMD RS780/SBX00.
+	  This option enables the hpet timer of LS2H or LS7A or AMD RS780/SBX00.
 
 	  If you want to enable the Loongson3 CPUFreq Driver, Please enable
 	  this option at first, otherwise, You will get wrong system time.
diff --git a/arch/mips/loongson64/common/env.c b/arch/mips/loongson64/common/env.c
index c742226ed..928c30754 100644
--- a/arch/mips/loongson64/common/env.c
+++ b/arch/mips/loongson64/common/env.c
@@ -190,8 +190,11 @@ void __init prom_init_env(void)
 		loongson_pch = &ls2h_pch;
 		loongson_sysconf.ec_sci_irq = 0x80;
 		loongson_fdt_blob = __dtb_loongson3_ls2h_begin;
-	}
-	else {
+	} else if (strstr(eboard->name,"7A")) {
+		loongson_pch = &ls7a_pch;
+		loongson_sysconf.ec_sci_irq = 0x7b;
+		loongson_fdt_blob = __dtb_loongson3_ls7a_begin;
+	} else {
 		loongson_pch = &rs780_pch;
 		loongson_sysconf.ec_sci_irq = 0x07;
 		loongson_fdt_blob = __dtb_loongson3_rs780_begin;
diff --git a/arch/mips/loongson64/common/rtc.c b/arch/mips/loongson64/common/rtc.c
index 17c2dd911..e68e795e9 100644
--- a/arch/mips/loongson64/common/rtc.c
+++ b/arch/mips/loongson64/common/rtc.c
@@ -35,6 +35,7 @@ static int __init loongson_rtc_platform_init(void)
 {
 	switch (loongson_pch->type) {
 	case LS2H:
+	case LS7A:
 	case RS780E:
 		break;
 	default:
diff --git a/arch/mips/loongson64/loongson-3/Makefile b/arch/mips/loongson64/loongson-3/Makefile
index 7fb36d084..1dba39134 100644
--- a/arch/mips/loongson64/loongson-3/Makefile
+++ b/arch/mips/loongson64/loongson-3/Makefile
@@ -3,7 +3,8 @@
 # Makefile for Loongson-3 family machines
 #
 obj-y			+= irq.o cop2-ex.o platform.o acpi_init.o dma.o clock.o constant_timer.o ec_wpce775l.o \
-			   ls2h-irq.o ls2h-platform.o rs780-irq.o rs780-platform.o workarounds.o
+			   ls2h-irq.o ls2h-platform.o ls7a-irq.o ls7a-platform.o rs780-irq.o rs780-platform.o \
+			   workarounds.o
 
 obj-$(CONFIG_SMP)	+= smp.o
 
@@ -14,3 +15,5 @@ obj-$(CONFIG_SUSPEND)	+= pm.o sleep.o
 obj-$(CONFIG_LOONGSON_HPET) += hpet.o
 
 obj-$(CONFIG_LOONGSON3_CPUAUTOPLUG) += loongson3_cpuautoplug.o
+
+obj-$(CONFIG_I2C_GPIO)	+= ls7a-gpio.o
diff --git a/arch/mips/loongson64/loongson-3/acpi_init.c b/arch/mips/loongson64/loongson-3/acpi_init.c
index e0c3b0a37..8f263ca7e 100644
--- a/arch/mips/loongson64/loongson-3/acpi_init.c
+++ b/arch/mips/loongson64/loongson-3/acpi_init.c
@@ -239,6 +239,13 @@ int __init loongson_acpi_init(void)
 		acpi_enable_reg  = LS2H_PM_ENA_REG;
 		gpe0_status_reg  = LS2H_GPE0_STS_REG;
 		break;
+	case LS7A:
+		acpi_irq = LS7A_PCH_ACPI_IRQ;
+		acpi_control_reg = LS7A_PM1_CNT_REG;
+		acpi_status_reg  = LS7A_PM1_EVT_REG;
+		acpi_enable_reg  = LS7A_PM1_ENA_REG;
+		gpe0_status_reg  = LS7A_GPE0_STS_REG;
+		break;
 	case RS780E:
 		acpi_irq = RS780_PCH_ACPI_IRQ;
 		acpi_control_reg = (void *)(mips_io_port_base + SBX00_PM_CNT_BLK + 0);
diff --git a/arch/mips/loongson64/loongson-3/dma.c b/arch/mips/loongson64/loongson-3/dma.c
index 2b5ea9bf6..4b617f743 100644
--- a/arch/mips/loongson64/loongson-3/dma.c
+++ b/arch/mips/loongson64/loongson-3/dma.c
@@ -209,6 +209,24 @@ static phys_addr_t loongson_ls2h_dma_to_phys(struct device *dev, dma_addr_t dadd
 		(daddr + loongson_sysconf.high_physmem_start - SZ_256M);
 }
 
+extern u32 node_id_offset;
+
+static dma_addr_t loongson_ls7a_phys_to_dma(struct device *dev, phys_addr_t paddr)
+{
+	/* We extract 2bit node id (bit 44~47, only bit 44~45 used now) from
+	 * Loongson-3's 48bit address space and embed it into 40bit */
+	long nid = (paddr >> 44) & 0x3;
+	return ((nid << 44) ^ paddr) | (nid << node_id_offset);
+}
+
+static phys_addr_t loongson_ls7a_dma_to_phys(struct device *dev, dma_addr_t daddr)
+{
+	/* We extract 2bit node id (bit 44~47, only bit 44~45 used now) from
+	 * Loongson-3's 48bit address space and embed it into 40bit */
+	long nid = (daddr >> node_id_offset) & 0x3;
+	return ((nid << node_id_offset) ^ daddr) | (nid << 44);
+}
+
 static dma_addr_t loongson_rs780_phys_to_dma(struct device *dev, phys_addr_t paddr)
 {
 	/* We extract 2bit node id (bit 44~47, only bit 44~45 used now) from
@@ -268,6 +286,10 @@ void __init plat_swiotlb_setup(void)
 		xlate_ops.phys_to_dma = loongson_ls2h_phys_to_dma;
 		xlate_ops.dma_to_phys = loongson_ls2h_dma_to_phys;
 		break;
+	case LS7A:
+		xlate_ops.phys_to_dma = loongson_ls7a_phys_to_dma;
+		xlate_ops.dma_to_phys = loongson_ls7a_dma_to_phys;
+		break;
 	case RS780E:
 		xlate_ops.phys_to_dma = loongson_rs780_phys_to_dma;
 		xlate_ops.dma_to_phys = loongson_rs780_dma_to_phys;
diff --git a/arch/mips/loongson64/loongson-3/hpet.c b/arch/mips/loongson64/loongson-3/hpet.c
index 4f9bf170a..1747101a8 100644
--- a/arch/mips/loongson64/loongson-3/hpet.c
+++ b/arch/mips/loongson64/loongson-3/hpet.c
@@ -231,6 +231,12 @@ void __init setup_hpet_timer(void)
 		hpet_mmio_base = LS2H_HPET_BASE;
 		hpet_irq_flags = HPET_TN_LEVEL;
 		break;
+	case LS7A:
+		hpet_freq = LS7A_HPET_FREQ;
+		hpet_t0_irq = LS7A_HPET_T0_IRQ;
+		hpet_mmio_base = LS7A_HPET_BASE;
+		hpet_irq_flags = HPET_TN_LEVEL;
+		break;
 	case RS780E:
 		hpet_freq = RS780_HPET_FREQ;
 		hpet_t0_irq = RS780_HPET_T0_IRQ;
diff --git a/arch/mips/loongson64/loongson-3/ls7a-gpio.c b/arch/mips/loongson64/loongson-3/ls7a-gpio.c
new file mode 100644
index 000000000..8337328e0
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/ls7a-gpio.c
@@ -0,0 +1,118 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/of.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <asm/types.h>
+
+#include <loongson.h>
+#include <loongson-pch.h>
+
+#define LS7A_GPIO_BASE  16
+#define LS7A_GPIO_DC	57
+#define LS7A_GPIO_NR	64
+
+#define LS7A_GPIO_BASE_REG (LS7A_MISC_REG_BASE + 0x00060000)
+
+#define LS7A_GPIO_EN_REG (void *)TO_UNCAC(LS7A_GPIO_BASE_REG + 0x800)
+#define LS7A_GPIO_IN_REG (void *)TO_UNCAC(LS7A_GPIO_BASE_REG + 0xa00)
+#define LS7A_GPIO_OUT_REG (void *)TO_UNCAC(LS7A_GPIO_BASE_REG + 0x900)
+
+#define PCICFG_BASE		0x1a000000
+#define LS7A_DC_BAR0_BASE	\
+	(readl((void *)TO_UNCAC(PCICFG_BASE | (6 << 11) | (1 << 8) | 0x10)) & 0xfffffff0)
+
+#define LS7A_DC_GPIO_IO_REG	(void *)TO_UNCAC(LS7A_DC_BAR0_BASE + 0x1650)
+#define LS7A_DC_GPIO_EN_REG	(void *)TO_UNCAC(LS7A_DC_BAR0_BASE + 0x1660)
+
+static inline int ls7a_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
+{
+	if (gpio < LS7A_GPIO_DC) {
+		if (readb(LS7A_GPIO_EN_REG + gpio))
+			return readb(LS7A_GPIO_IN_REG + gpio) & BIT(0);
+		else
+			return readq(LS7A_GPIO_OUT_REG + gpio) & BIT(0);
+	} else {
+		gpio -= LS7A_GPIO_DC;
+		return readl(LS7A_DC_GPIO_IO_REG) & (1 << gpio);
+	}
+}
+
+static inline void ls7a_gpio_set_value(struct gpio_chip *chip, unsigned gpio, int value)
+{
+	unsigned long tmp;
+
+	if (gpio < LS7A_GPIO_DC) {
+		tmp = readb(LS7A_GPIO_OUT_REG + gpio) & ~BIT(0);
+		if (value)
+			tmp |= BIT(0);
+		writeb(tmp, LS7A_GPIO_OUT_REG + gpio);
+	} else {
+		gpio -= LS7A_GPIO_DC;
+		tmp = readl(LS7A_DC_GPIO_IO_REG) & ~(1 << gpio);
+		if (value)
+			tmp |= 1ULL << gpio;
+		writel(tmp, LS7A_DC_GPIO_IO_REG);
+	}
+}
+
+static inline int ls7a_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
+{
+	if (gpio >= LS7A_GPIO_NR)
+		return -EINVAL;
+
+	if (gpio < LS7A_GPIO_DC)
+		writeb(readb(LS7A_GPIO_EN_REG + gpio) | BIT(0), LS7A_GPIO_EN_REG + gpio);
+	else {
+		gpio -= LS7A_GPIO_DC;
+		writel(readl(LS7A_DC_GPIO_EN_REG) | (1ULL << gpio), LS7A_DC_GPIO_EN_REG);
+	}
+
+	return 0;
+}
+
+static inline int ls7a_gpio_direction_output(struct gpio_chip *chip, unsigned gpio, int value)
+{
+	if (gpio >= LS7A_GPIO_NR)
+		return -EINVAL;
+
+	ls7a_gpio_set_value(chip, gpio, value);
+	if (gpio < LS7A_GPIO_DC)
+		writeb(readq(LS7A_GPIO_EN_REG + gpio) & ~BIT(0), LS7A_GPIO_EN_REG + gpio);
+	else {
+		gpio -= LS7A_GPIO_DC;
+		writel(readl(LS7A_DC_GPIO_EN_REG) & ~(1ULL << gpio), LS7A_DC_GPIO_EN_REG);
+	}
+
+	return 0;
+}
+
+static struct gpio_chip ls7a_gpio_chip = {
+	.label			= "ls7a-gpio-chip",
+	.direction_input	= ls7a_gpio_direction_input,
+	.get			= ls7a_gpio_get_value,
+	.direction_output	= ls7a_gpio_direction_output,
+	.set			= ls7a_gpio_set_value,
+	.base			= LS7A_GPIO_BASE,
+	.ngpio			= LS7A_GPIO_NR,
+};
+
+static struct of_device_id ls7a_gpio_ids[] __initdata = {
+	{ .compatible = "loongson,ls7a-gpio", },
+	{},
+};
+
+static int __init ls7a_gpio_setup(void)
+{
+	struct device_node *np;
+
+	for_each_matching_node(np, ls7a_gpio_ids) {
+		ls7a_gpio_chip.of_node = np;
+		gpiochip_add(&ls7a_gpio_chip);
+	}
+
+	return 0;
+}
+arch_initcall(ls7a_gpio_setup);
diff --git a/arch/mips/loongson64/loongson-3/ls7a-irq.c b/arch/mips/loongson64/loongson-3/ls7a-irq.c
new file mode 100644
index 000000000..4f34af93d
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/ls7a-irq.c
@@ -0,0 +1,213 @@
+/*
+ *  Copyright (C) 2017, Loongson Technology Corporation Limited, Inc.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ */
+#include <linux/interrupt.h>
+#include <linux/irqchip.h>
+#include <linux/module.h>
+
+#include <asm/irq_cpu.h>
+#include <asm/i8259.h>
+#include <asm/mipsregs.h>
+#include <irq.h>
+#include <loongson.h>
+#include <loongson-pch.h>
+
+static unsigned int irq_cpu[NR_IRQS] = {[0 ... NR_IRQS-1] = -1};
+
+static DEFINE_RAW_SPINLOCK(pch_irq_lock);
+
+static void mask_pch_irq(struct irq_data *d)
+{
+	int irq_nr;
+	unsigned long flags;
+
+	if (d->irq < 16) {
+		local_irq_save(flags);
+		writel(readl(LS7A_LPC_INT_ENA) & ~(0x1 << (d->irq)), LS7A_LPC_INT_ENA);
+		local_irq_restore(flags);
+	} else {
+		raw_spin_lock_irqsave(&pch_irq_lock, flags);
+		irq_nr = d->irq - LS7A_PCH_IRQ_BASE;
+		writeq(readq(LS7A_INT_MASK_REG) | (1ULL << irq_nr), LS7A_INT_MASK_REG);
+		raw_spin_unlock_irqrestore(&pch_irq_lock, flags);
+	}
+}
+
+static void unmask_pch_irq(struct irq_data *d)
+{
+	int irq_nr;
+	unsigned long flags;
+
+	if (d->irq < 16) {
+		local_irq_save(flags);
+		writel(readl(LS7A_LPC_INT_ENA) | (0x1 << (d->irq)), LS7A_LPC_INT_ENA);
+		local_irq_restore(flags);
+	} else {
+		raw_spin_lock_irqsave(&pch_irq_lock, flags);
+		irq_nr = d->irq - LS7A_PCH_IRQ_BASE;
+		writeq(readq(LS7A_INT_MASK_REG) & ~(1ULL << irq_nr), LS7A_INT_MASK_REG);
+		raw_spin_unlock_irqrestore(&pch_irq_lock, flags);
+	}
+}
+
+static struct irq_chip pch_irq_chip = {
+	.name			= "Loongson",
+	.irq_mask		= mask_pch_irq,
+	.irq_unmask		= unmask_pch_irq,
+	.irq_set_affinity	= plat_set_irq_affinity,
+	.flags			= IRQCHIP_MASK_ON_SUSPEND,
+};
+
+#define LPC_OFFSET 19
+
+/* Handle LPC IRQs */
+static irqreturn_t lpc_irq_dispatch(int irq, void *data)
+{
+	int irqs;
+
+	irqs = readl(LS7A_LPC_INT_ENA) & readl(LS7A_LPC_INT_STS);
+	if (!irqs)
+		return IRQ_NONE;
+
+	while ((irq = ffs(irqs))) {
+		do_IRQ(irq - 1);
+		irqs &= ~(1 << (irq - 1));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction lpc_irqaction = {
+	.name = "lpc",
+	.flags = IRQF_NO_THREAD,
+	.handler = lpc_irq_dispatch,
+};
+
+void ls7a_irq_dispatch(void)
+{
+	struct irq_data *irqd;
+	struct cpumask affinity;
+	unsigned long irq, flags, intmask, intstatus;
+
+	raw_spin_lock_irqsave(&pch_irq_lock, flags);
+	intmask = readq(LS7A_INT_MASK_REG);
+	intstatus = readq(LS7A_INT_STATUS_REG);
+	writeq((intstatus | intmask), LS7A_INT_MASK_REG);
+	raw_spin_unlock_irqrestore(&pch_irq_lock, flags);
+
+	/* Handle normal IRQs */
+	while (intstatus) {
+		irq = __ffs(intstatus);
+		intstatus &= ~(1ULL << irq);
+		irq = LS7A_PCH_IRQ_BASE + irq;
+
+		/* handled by local core */
+		if (loongson_ipi_irq2pos[irq] == -1) {
+			do_IRQ(irq);
+			continue;
+		}
+
+		irqd = irq_get_irq_data(irq);
+		cpumask_and(&affinity, irqd->common->affinity, cpu_active_mask);
+		if (cpumask_empty(&affinity)) {
+			do_IRQ(irq);
+			continue;
+		}
+
+		irq_cpu[irq] = cpumask_next(irq_cpu[irq], &affinity);
+		if (irq_cpu[irq] >= nr_cpu_ids)
+			irq_cpu[irq] = cpumask_first(&affinity);
+
+		if (irq_cpu[irq] == 0) {
+			do_IRQ(irq);
+			continue;
+		}
+
+		/* balanced by other cores */
+		loongson3_send_irq_by_ipi(irq_cpu[irq], (0x1 << (loongson_ipi_irq2pos[irq])));
+	}
+}
+
+void ls7a_init_irq(void)
+{
+	int i;
+
+	/* Route LPC int to cpu Core0 INT0 */
+	LOONGSON_INT_ROUTER_LPC = LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 0);
+	LOONGSON_INT_ROUTER_INTENSET = LOONGSON_INT_ROUTER_INTEN | 0x1 << 10;
+
+	/* Route INTn0 to Core0 INT1 (IP3) */
+	LOONGSON_INT_ROUTER_ENTRY(0) = LOONGSON_INT_COREx_INTy(loongson_sysconf.boot_cpu_id, 1);
+	LOONGSON_INT_ROUTER_INTENSET = LOONGSON_INT_ROUTER_INTEN | 0x1 << 0;
+
+	/* Route IRQs to LS7A INT0 */
+	for (i = LS7A_PCH_IRQ_BASE; i < LS7A_PCH_LAST_IRQ; i++)
+		writeb(0x1, (LS7A_INT_ROUTE_ENTRY_REG + i - LS7A_PCH_IRQ_BASE));
+
+	writeq(0x0ULL, LS7A_INT_EDGE_REG);
+	writeq(0x0ULL, LS7A_INT_STATUS_REG);
+	/* Mask all interrupts except LPC (bit 19) */
+	writeq(0xfffffffffff7ffffULL, LS7A_INT_MASK_REG);
+	writeq(0xffffffffffffffffULL, LS7A_INT_CLEAR_REG);
+
+	/* Enable the LPC interrupt */
+	writel(0x80000000, LS7A_LPC_INT_CTL);
+	/* Clear all 18-bit interrupt bits */
+	writel(0x3ffff, LS7A_LPC_INT_CLR);
+
+	for (i = 0; i < NR_IRQS; i++)
+		loongson_ipi_irq2pos[i] = -1;
+	for (i = 0; i < NR_DIRQS; i++)
+		loongson_ipi_pos2irq[i] = -1;
+	create_ipi_dirq(LS7A_PCH_SATA0_IRQ);
+	create_ipi_dirq(LS7A_PCH_SATA1_IRQ);
+	create_ipi_dirq(LS7A_PCH_SATA2_IRQ);
+	create_ipi_dirq(LS7A_PCH_GMAC0_SBD_IRQ);
+	create_ipi_dirq(LS7A_PCH_GMAC1_SBD_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_F0_PORT0_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_F0_PORT1_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_F0_PORT2_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_F0_PORT3_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_F1_PORT0_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_F1_PORT1_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_G0_LO_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_G0_HI_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_G1_LO_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_G1_HI_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_H_LO_IRQ);
+	create_ipi_dirq(LS7A_PCH_PCIE_H_HI_IRQ);
+	create_ipi_dirq(LS7A_PCH_EHCI0_IRQ);
+	create_ipi_dirq(LS7A_PCH_EHCI1_IRQ);
+	create_ipi_dirq(LS7A_PCH_OHCI0_IRQ);
+	create_ipi_dirq(LS7A_PCH_OHCI1_IRQ);
+}
+
+int __init ls7a_irq_of_init(struct device_node *node, struct device_node *parent)
+{
+	u32 i;
+
+	irq_domain_add_legacy(node, 64, LS7A_PCH_IRQ_BASE,
+			LS7A_PCH_IRQ_BASE, &irq_domain_simple_ops, NULL);
+
+	irq_set_chip_and_handler(1, &pch_irq_chip, handle_level_irq);
+	irq_set_chip_and_handler(4, &pch_irq_chip, handle_level_irq);
+	irq_set_chip_and_handler(5, &pch_irq_chip, handle_level_irq);
+	irq_set_chip_and_handler(12, &pch_irq_chip, handle_level_irq);
+
+	for (i = LS7A_PCH_IRQ_BASE; i < LS7A_PCH_LAST_IRQ; i++)
+		irq_set_chip_and_handler(i, &pch_irq_chip, handle_level_irq);
+	setup_irq(LS7A_PCH_IRQ_BASE + LPC_OFFSET, &lpc_irqaction);
+
+	return 0;
+}
+IRQCHIP_DECLARE(plat_intc, "loongson,ls7a-interrupt-controller", ls7a_irq_of_init);
diff --git a/arch/mips/loongson64/loongson-3/ls7a-platform.c b/arch/mips/loongson64/loongson-3/ls7a-platform.c
new file mode 100644
index 000000000..7337aa771
--- /dev/null
+++ b/arch/mips/loongson64/loongson-3/ls7a-platform.c
@@ -0,0 +1,76 @@
+/*
+ *  Copyright (C) 2013, Loongson Technology Corporation Limited, Inc.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ */
+#include <linux/init.h>
+#include <asm/io.h>
+#include <pci.h>
+#include <boot_param.h>
+#include <loongson-pch.h>
+
+#include <linux/serial_8250.h>
+#include <linux/platform_device.h>
+
+#include <linux/i2c.h>
+#include <linux/platform_data/i2c-gpio.h>
+
+u32 node_id_offset;
+
+#define LS7A_DMA_CFG	(void *)TO_UNCAC(LS7A_CHIPCFG_REG_BASE + 0x041c)
+
+static void ls7a_early_config(void)
+{
+	node_id_offset = ((readl(LS7A_DMA_CFG) & 0x1f00) >> 8) + 36;
+}
+
+static struct resource pci_mem_resource = {
+	.name	= "pci memory space",
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct resource pci_io_resource = {
+	.name	= "pci io space",
+	.flags	= IORESOURCE_IO,
+};
+
+static struct pci_controller ls7a_pci_controller = {
+	.pci_ops	= &ls7a_pci_ops,
+	.io_resource	= &pci_io_resource,
+	.mem_resource	= &pci_mem_resource,
+	.mem_offset	= 0x00000000UL,
+	.io_offset	= 0x00000000UL,
+};
+
+static void __init ls7a_arch_initcall(void)
+{
+	pci_mem_resource.start = loongson_sysconf.pci_mem_start_addr;
+	pci_mem_resource.end   = loongson_sysconf.pci_mem_end_addr;
+	pci_io_resource.start  = 0x20000;
+	pci_io_resource.end    = 0x3ffff;
+	ioport_resource.end    = 0xfffff;
+	ls7a_pci_controller.io_map_base = mips_io_port_base;
+	register_pci_controller(&ls7a_pci_controller);
+}
+
+static void __init ls7a_device_initcall(void)
+{
+}
+
+struct platform_controller_hub ls7a_pch = {
+	.type			= LS7A,
+	.pcidev_max_funcs 	= 7,
+	.early_config		= ls7a_early_config,
+	.init_irq		= ls7a_init_irq,
+	.irq_dispatch		= ls7a_irq_dispatch,
+	.pch_arch_initcall	= ls7a_arch_initcall,
+	.pch_device_initcall	= ls7a_device_initcall,
+};
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index 6c677c374..4ce35ef59 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -35,7 +35,7 @@ obj-$(CONFIG_LASAT)		+= pci-lasat.o
 obj-$(CONFIG_MIPS_COBALT)	+= fixup-cobalt.o
 obj-$(CONFIG_LEMOTE_FULOONG2E)	+= fixup-fuloong2e.o ops-loongson2.o
 obj-$(CONFIG_LEMOTE_MACH2F)	+= fixup-lemote2f.o ops-loongson2.o
-obj-$(CONFIG_LOONGSON_MACH3X)	+= fixup-loongson3.o ops-loongson3-ls2h.o ops-loongson3-rs780.o
+obj-$(CONFIG_LOONGSON_MACH3X)	+= fixup-loongson3.o ops-loongson3-ls2h.o ops-loongson3-ls7a.o ops-loongson3-rs780.o
 obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o pci-malta.o
 obj-$(CONFIG_PMC_MSP7120_GW)	+= fixup-pmcmsp.o ops-pmcmsp.o
 obj-$(CONFIG_PMC_MSP7120_EVAL)	+= fixup-pmcmsp.o ops-pmcmsp.o
diff --git a/arch/mips/pci/ops-loongson3-ls7a.c b/arch/mips/pci/ops-loongson3-ls7a.c
new file mode 100644
index 000000000..b057c163c
--- /dev/null
+++ b/arch/mips/pci/ops-loongson3-ls7a.c
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) Lemote, Inc.
+ * Author: Huacai Chen <chenhc@lemote.com>
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+
+#include <asm/mips-boards/bonito64.h>
+
+#include <loongson.h>
+
+#define PCI_ACCESS_READ  0
+#define PCI_ACCESS_WRITE 1
+
+#define HT1LO_PCICFG_BASE      0x1a000000
+#define HT1LO_PCICFG_BASE_TP1  0x1b000000
+
+#define HT1LO_PCICFG_BASE_EXTEND 	0xefe00000000
+#define HT1LO_PCICFG_BASE_TP1_EXTEND 	0xefe10000000
+
+static int ls7a_pci_config_access(unsigned char access_type,
+		struct pci_bus *bus, unsigned int devfn,
+		int where, u32 *data)
+{
+	u_int64_t addr;
+	void *addrp;
+	unsigned char busnum = bus->number;
+	int device = PCI_SLOT(devfn);
+	int function = PCI_FUNC(devfn);
+	int reg = where & ~3;
+
+	/** Filter out non-supported devices.
+	 *  device 2: misc, device 21: confbus
+	 */
+	if (where < PCI_CFG_SPACE_SIZE) { /* standard config */
+		addr = (busnum << 16) | (device << 11) | (function << 8) | reg;
+		if (busnum == 0) {
+			if (device > 23)
+				return PCIBIOS_DEVICE_NOT_FOUND;
+			addrp = (void *)TO_UNCAC(HT1LO_PCICFG_BASE | addr);
+		} else {
+			addrp = (void *)TO_UNCAC(HT1LO_PCICFG_BASE_TP1 | addr);
+		}
+	} else if (where < PCI_CFG_SPACE_EXP_SIZE) {  /* extended config */
+		reg = (reg & 0xff) | ((reg & 0xf00) << 16);
+		addr = (busnum << 16) | (device << 11) | (function << 8) | reg;
+		if (busnum == 0) {
+			if (device > 23)
+				return PCIBIOS_DEVICE_NOT_FOUND;
+			addrp = (void *)TO_UNCAC(HT1LO_PCICFG_BASE_EXTEND | addr);
+		} else {
+			addrp = (void *)TO_UNCAC(HT1LO_PCICFG_BASE_TP1_EXTEND | addr);
+		}
+	} else {
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	if (access_type == PCI_ACCESS_WRITE)
+		writel(*data, addrp);
+	else {
+		*data = readl(addrp);
+		if (busnum == 0 && reg == PCI_CLASS_REVISION && *data == 0x06000001)
+			*data = (PCI_CLASS_BRIDGE_PCI << 16) | (*data & 0xffff);
+
+		if (*data == 0xffffffff) {
+			*data = -1;
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		}
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ls7a_pci_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 * val)
+{
+	u32 data = 0;
+	int ret = ls7a_pci_config_access(PCI_ACCESS_READ,
+			bus, devfn, where, &data);
+
+	if (ret != PCIBIOS_SUCCESSFUL)
+		return ret;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ls7a_pci_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 val)
+{
+	u32 data = 0;
+	int ret;
+
+	if (size == 4)
+		data = val;
+	else {
+		ret = ls7a_pci_config_access(PCI_ACCESS_READ,
+				bus, devfn, where, &data);
+		if (ret != PCIBIOS_SUCCESSFUL)
+			return ret;
+
+		if (size == 1)
+			data = (data & ~(0xff << ((where & 3) << 3))) |
+			    (val << ((where & 3) << 3));
+		else if (size == 2)
+			data = (data & ~(0xffff << ((where & 3) << 3))) |
+			    (val << ((where & 3) << 3));
+	}
+
+	ret = ls7a_pci_config_access(PCI_ACCESS_WRITE,
+			bus, devfn, where, &data);
+	if (ret != PCIBIOS_SUCCESSFUL)
+		return ret;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops ls7a_pci_ops = {
+	.read = ls7a_pci_pcibios_read,
+	.write = ls7a_pci_pcibios_write
+};
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 57cbe4a4b..dee38523c 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -40,6 +40,7 @@
 enum {
 	AHCI_PCI_BAR_STA2X11	= 0,
 	AHCI_PCI_BAR_CAVIUM	= 0,
+	AHCI_PCI_BAR_LOONGSON	= 0,
 	AHCI_PCI_BAR_ENMOTUS	= 2,
 	AHCI_PCI_BAR_CAVIUM_GEN5	= 4,
 	AHCI_PCI_BAR_STANDARD	= 5,
@@ -579,6 +580,9 @@ static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Enmotus */
 	{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },
 
+	/* Loongson */
+	{ PCI_VDEVICE(LOONGSON, 0x7a08), board_ahci },
+
 	/* Generic, PCI class code for AHCI */
 	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },
@@ -1690,6 +1694,8 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		if (pdev->device == 0xa084)
 			ahci_pci_bar = AHCI_PCI_BAR_CAVIUM_GEN5;
 	}
+	else if (pdev->vendor == PCI_VENDOR_ID_LOONGSON && pdev->device == 0x7a08)
+		ahci_pci_bar = AHCI_PCI_BAR_LOONGSON;
 
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
diff --git a/drivers/platform/mips/emc1412.c b/drivers/platform/mips/emc1412.c
index 02f228474..3e099b33b 100644
--- a/drivers/platform/mips/emc1412.c
+++ b/drivers/platform/mips/emc1412.c
@@ -118,18 +118,28 @@ static const struct attribute *emc1412_hwmon_temp[4][5] = {
 	}
 };
 
+#define BUS_MASK  0xffffffff00000000ul
+#define ADDR_MASK 0x00000000fffffffful
+
 static int emc1412_probe(struct platform_device *dev)
 {
-	struct i2c_adapter *adapter = NULL;
+	char i2c_name[16];
 	struct i2c_board_info info;
-	int i = 0, r = 0, found = 0, id = dev->id - 1;
+	struct i2c_adapter *adapter = NULL;
+	int i = 0, r = 0, found = 0, i2c_bus, id = dev->id - 1;
 	struct sensor_device *sdev = (struct sensor_device *)dev->dev.platform_data;
 
 	memset(&info, 0, sizeof(struct i2c_board_info));
 
+	i2c_bus = ((sdev->base_addr & BUS_MASK) >> 32) - 1;
+	if (i2c_bus < 0)
+		sprintf(i2c_name, "SMBus PIIX4");
+	else
+		sprintf(i2c_name, "LS2X I2C%d", i2c_bus);
+
 	adapter = i2c_get_adapter(i++);
 	while (adapter) {
-		if (strncmp(adapter->name, "SMBus PIIX4", 11) == 0) {
+		if (strncmp(adapter->name, i2c_name, strlen(i2c_name)) == 0) {
 			found = 1;
 			break;
 		}
@@ -140,7 +150,7 @@ static int emc1412_probe(struct platform_device *dev)
 	if (!found)
 		goto fail;
 
-	info.addr = sdev->base_addr;
+	info.addr = sdev->base_addr & ADDR_MASK;
 	info.platform_data = dev->dev.platform_data;
 	strncpy(info.type, "emc1412", I2C_NAME_SIZE);
 	emc1412_client[id] = i2c_new_device(adapter, &info);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index d35000669..50b70bcee 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -3131,4 +3131,16 @@
 
 #define PCI_VENDOR_ID_NCUBE		0x10ff
 
+#define PCI_VENDOR_ID_LOONGSON		0x0014
+#define PCI_DEVICE_ID_LOONGSON_APB	0x7a02
+#define PCI_DEVICE_ID_LOONGSON_GMAC	0x7a03
+#define PCI_DEVICE_ID_LOONGSON_DC	0x7a06
+#define PCI_DEVICE_ID_LOONGSON_HDA	0x7a07
+#define PCI_DEVICE_ID_LOONGSON_GPU	0x7a15
+#define PCI_DEVICE_ID_LOONGSON_AHCI	0x7a08
+#define PCI_DEVICE_ID_LOONGSON_EHCI	0x7a14
+#define PCI_DEVICE_ID_LOONGSON_OHCI	0x7a24
+#define PCI_DEVICE_ID_LOONGSON_LPC	0x7a0c
+#define PCI_DEVICE_ID_LOONGSON_DMA	0x7a0f
+
 #endif /* _LINUX_PCI_IDS_H */
-- 
2.39.1

